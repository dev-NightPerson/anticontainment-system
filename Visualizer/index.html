<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <title>Visualizer</title>
  <style>
    html, body { height: 100%; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 50% 50%, #0b0b0b 0%, #050505 60%, #000 100%);
      overflow: hidden;
      cursor: none; /* no text, no cursor */
      user-select: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    /* Subtle vignette overlay to push depth perception */
    .vignette {
      position: fixed; inset: 0; pointer-events: none;
      background: radial-gradient(1200px 800px at 50% 50%, rgba(0,0,0,0) 40%, rgba(0,0,0,0.35) 100%);
      mix-blend-mode: multiply;
    }
    /* Slide-up panel */
    .dock-zone { position: fixed; left: 0; right: 0; bottom: 0; height: 18px; z-index: 9001; }
    .panel { position: fixed; left: 0; right: 0; bottom: -260px; height: 260px; background: rgba(10,8,6,0.92);
      border-top: 1px solid rgba(255,200,150,0.15); box-shadow: 0 -10px 30px rgba(0,0,0,0.4);
      backdrop-filter: blur(6px); z-index: 9000; color: #e7c39a; transition: transform 240ms ease, bottom 240ms ease;
      transform: translateY(0);
    }
    .panel.show { bottom: 0; }
    .panel-inner { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 12px 16px; height: 100%; }
    .section { border: 1px solid rgba(255,200,150,0.12); padding: 10px; border-radius: 8px; background: rgba(20,16,12,0.6); }
    /* Small buttons for the top-right settings toolbar */
    .btn-sm { font-size: 12px; padding: 4px 8px; line-height: 1; }
    .pill.btn-sm { padding: 4px 8px; font-size: 12px; }
    #settingsToolbar { gap: 6px; }
    #settingsToolbar #lblImport { display: inline-flex; align-items: center; white-space: nowrap; }
    /* Compact sliders */
    input[type="range"] { -webkit-appearance: none; appearance: none; height: 4px; background: rgba(255,200,150,0.25); border-radius: 4px; outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; background: #e7c39a; border: 1px solid rgba(0,0,0,0.6); box-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    input[type="range"]::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: #e7c39a; border: 1px solid rgba(0,0,0,0.6); box-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    /* Panel slider widths (keep compact so they don't wrap) */
    .panel .row .pill input[type="range"] { width: 110px; min-width: 110px; }
    /* Sensitivity sliders even narrower to keep all on one line */
    #sensBass, #sensMid, #sensTreble, #sensThunderIntensity { width: 90px !important; min-width: 90px !important; }
    /* Prevent wrapping in rows and labels */
    .panel .row { display: flex; flex-wrap: nowrap; align-items: center; gap: 10px; }
    .panel .row .pill { white-space: nowrap; }
    /* Specific elements keep their own sizes */
    #seek { height: 4px; }
    #volume { height: 4px; }
    /* Live/Kick/VDO window chrome slider compact */
    .video-window .chrome input[type="range"], #liveOpacityBar, #kickOpacity, #vdoOpacity { width: 110px; height: 4px; }
    /* Dark checkbox toggles (custom styling, cross-browser) */
    input[type="checkbox"], .panel input[type="checkbox"], .video-window .chrome input[type="checkbox"] {
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      width: 14px; height: 14px; vertical-align: middle;
      border: 1px solid rgba(255,200,150,0.25); border-radius: 3px;
      background: rgba(20,16,12,0.95); position: relative; display:inline-block;
    }
    input[type="checkbox"]:hover { box-shadow: 0 0 0 2px rgba(255,200,150,0.12) inset; }
    input[type="checkbox"]:focus { outline: none; box-shadow: 0 0 0 2px rgba(255,200,150,0.18); }
    input[type="checkbox"]:checked { background: #2b2016; border-color: rgba(255,200,150,0.45); }
    input[type="checkbox"]:checked::after { content: ""; position: absolute; left: 3px; top: 1px; width: 6px; height: 10px; border: solid #e7c39a; border-width: 0 2px 2px 0; transform: rotate(45deg); }
    /* Mode-based visibility guards */
    body.mode-player #liveControlsRow,
    body.mode-player #liveWindowsList,
    body.mode-player #liveRight { display: none !important; }
    body.mode-messages #liveControlsRow,
    body.mode-messages #liveWindowsList,
    body.mode-messages #liveRight { display: none !important; }
    /* Dark dropdowns */
    select, .panel select, .yt-modal select {
      background: rgba(20,16,12,0.95);
      color: #e7c39a;
      border: 1px solid rgba(255,200,150,0.22);
      border-radius: 6px;
      padding: 4px 8px;
    }
    select:focus { outline: none; box-shadow: 0 0 0 2px rgba(255,200,150,0.2); }
    /* Some browsers honor option colors */
    select option { background-color: rgba(20,16,12,0.98); color: #e7c39a; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 0 0 auto; }
    /* Bronze theme controls */
    button, select, input[type="text"], input[type="number"], input[type="file"] {
      background: linear-gradient(180deg, rgba(58,42,30,0.95), rgba(40,30,22,0.95));
      color: #ffd7a6; border: 1px solid rgba(255,200,150,0.28);
      padding: 6px 10px; border-radius: 8px; outline: none; font: inherit;
      box-shadow: inset 0 0 0 1px rgba(110,75,48,0.25), 0 2px 8px rgba(0,0,0,0.35);
      text-shadow: 0 1px 0 rgba(0,0,0,0.45);
    }
    button { transition: transform 80ms ease, box-shadow 150ms ease, background 150ms ease; }
    button:hover { background: linear-gradient(180deg, rgba(74,52,37,0.98), rgba(48,36,26,0.98)); box-shadow: inset 0 0 0 1px rgba(140,95,60,0.35), 0 4px 14px rgba(0,0,0,0.45); }
    button:active { transform: translateY(1px); box-shadow: inset 0 0 0 1px rgba(180,120,75,0.45), 0 2px 8px rgba(0,0,0,0.5); }
    /* Icon-like buttons (prev/play/next/shuffle/repeat) inherit above and get extra glow on hover */
    #btnPrev, #btnPlay, #btnNext, #btnShuffle, #btnRepeat { font-size: 15px; }
    #btnPrev:hover, #btnPlay:hover, #btnNext:hover, #btnShuffle:hover, #btnRepeat:hover { box-shadow: 0 0 18px rgba(217,150,91,0.25), inset 0 0 0 1px rgba(180,120,75,0.45); }
    /* Bronze icons */
    #btnShuffle i, #btnRepeat i { color: #d99a5b; text-shadow: 0 0 6px rgba(217,150,91,0.25); }
    #btnShuffle.active i, #btnRepeat.active i { color: #ffcd96; filter: drop-shadow(0 0 8px rgba(217,150,91,0.45)); }

    /* Themed selects */
    select { appearance: none; background-image: linear-gradient(180deg, rgba(58,42,30,0.95), rgba(40,30,22,0.95)); }
    select:focus { border-color: rgba(255,200,150,0.45); box-shadow: 0 0 0 2px rgba(217,150,91,0.25); }

    /* Checkboxes, radios accent */
    input[type="checkbox"], input[type="radio"] { accent-color: #b97a49; }

    /* Themed range sliders */
    input[type="range"] { height: 20px; background: transparent; }
    /* WebKit */
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; border-radius: 999px; background: linear-gradient(90deg, rgba(95,63,41,0.9), rgba(64,44,30,0.9)); box-shadow: inset 0 0 0 1px rgba(150,100,66,0.25); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; margin-top: -5px; border-radius: 50%; border: 1px solid rgba(255,200,150,0.5); background: radial-gradient(circle at 30% 30%, #f5c58f, #b47441 65%, #7a4a2b 100%); box-shadow: 0 0 10px rgba(217,150,91,0.35); }
    /* Firefox */
    input[type="range"]::-moz-range-track { height: 6px; border-radius: 999px; background: linear-gradient(90deg, rgba(95,63,41,0.9), rgba(64,44,30,0.9)); box-shadow: inset 0 0 0 1px rgba(150,100,66,0.25); }
    input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(255,200,150,0.5); background: radial-gradient(circle at 30% 30%, #f5c58f, #b47441 65%, #7a4a2b 100%); box-shadow: 0 0 10px rgba(217,150,91,0.35); }
    input[type="range"]::-moz-focus-outer { border: 0; }
    .grow { flex: 1 1 auto; }
    .list { max-height: 120px; overflow: auto; padding: 6px; border: 1px dashed rgba(255,200,150,0.2); border-radius: 6px; }
    /* Playlist on right: fixed-height scroll area and themed scrollbars */
    #playlistSection { display: flex; flex-direction: column; }
    #playlistSection #playlistMount .list { height: 180px; max-height: 180px; overflow: auto; }
    /* WebKit themed scrollbar */
    #playlistSection .list::-webkit-scrollbar { width: 10px; height: 10px; }
    #playlistSection .list::-webkit-scrollbar-track { background: rgba(35,26,19,0.8); border-radius: 8px; }
    #playlistSection .list::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #8c5a34, #b97a49); border-radius: 8px; border: 2px solid rgba(35,26,19,0.9); }
    #playlistSection .list::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg, #a86c3f, #cf8a55); }
    /* Firefox themed scrollbar */
    #playlistSection .list { scrollbar-width: thin; scrollbar-color: #b97a49 rgba(35,26,19,0.8); }
    /* Playlist peek mode: keep space, dim, and disable interaction */
    #playlistSection.peek { opacity: 0.25; filter: grayscale(80%); position: relative; pointer-events: none; }
    #playlistSection.peek::after { content: 'Playlist (peek)'; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: rgba(233,196,150,0.45); font-weight: 700; letter-spacing: 0.08em; backdrop-filter: none; pointer-events: none; }
    /* Badges */
    .badge { display:inline-block; padding:2px 6px; border-radius: 6px; font-size:11px; margin-left:8px; opacity:0.9; }
    .badge.session { background: rgba(255,200,150,0.12); border:1px solid rgba(255,200,150,0.25); color:#eac39a; }
    .pill { padding: 4px 8px; border: 1px solid rgba(255,200,150,0.2); border-radius: 999px; font-size: 12px; opacity: 0.85; }
    .handle { cursor: grab; }
    .link { cursor: pointer; }
    /* Always show cursor over UI elements */
    .dock-zone, .panel, .panel * { cursor: auto !important; }
    .panel button, .panel .pill, .panel label { cursor: pointer; }
    .panel input[type="text"], .panel input[type="number"], .panel input[type="range"], .panel select, .panel textarea { cursor: auto; }
    /* Themed scrollbar for preview */
    #msgPreviewBox .scrollbox { scrollbar-width: thin; scrollbar-color: rgba(186,120,72,0.6) rgba(30,24,18,0.6); }
    #msgPreviewBox .scrollbox::-webkit-scrollbar { width: 8px; }
    #msgPreviewBox .scrollbox::-webkit-scrollbar-track { background: rgba(30,24,18,0.6); border-radius: 8px; }
    #msgPreviewBox .scrollbox::-webkit-scrollbar-thumb { background: linear-gradient(180deg, rgba(240,170,100,0.35), rgba(186,120,72,0.65)); border-radius: 8px; border: 1px solid rgba(255,200,150,0.25); }
    #msgPreviewBox .scrollbox::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg, rgba(240,170,100,0.5), rgba(186,120,72,0.85)); }
    /* Future modals and overlays should also show cursor */
    .overlay, .overlay * { cursor: auto !important; }
    /* Message overlay */
    .overlay { position: fixed; inset: 0; pointer-events: none; z-index: 10; }
    .message-paragraph { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      color: #f0c99b; opacity: 0.0; font-weight: 800; letter-spacing: 0.02em;
      font-family: Impact, Haettenschweiler, 'Arial Black', 'Segoe UI Black', sans-serif;
      text-transform: uppercase;
      white-space: pre-line;
      /* strong multi-layer glow and dark separation */
      -webkit-text-stroke: 1px rgba(0,0,0,0.65);
      text-shadow:
        0 2px 2px rgba(0,0,0,0.75),
        0 0 12px rgba(240,170,100,0.45),
        0 0 24px rgba(240,170,100,0.25);
      filter: drop-shadow(0 3px 10px rgba(0,0,0,0.65));
      pointer-events: none; }
    /* Soft dark score behind paragraph text without a border */
    .message-paragraph::before { content: ""; position: absolute; z-index: -2; pointer-events: none;
      left: -0.6em; right: -0.6em; top: -0.3em; bottom: -0.25em;
      background: radial-gradient(120% 120% at 50% 50%, rgba(0,0,0,0.55), rgba(0,0,0,0.2));
      /* Blur the element itself (soft score) and frost what's behind it */
      filter: blur(var(--msgBackdropBlur, 8px));
      backdrop-filter: blur(var(--msgFrostPx, 12px)) brightness(var(--msgFrostBright, 0.72)) saturate(var(--msgFrostSat, 0.65));
      -webkit-backdrop-filter: blur(var(--msgFrostPx, 12px)) brightness(var(--msgFrostBright, 0.72)) saturate(var(--msgFrostSat, 0.65));
      opacity: var(--msgBackdropOpacity, 0.9); border-radius: 6px; }
    /* Crisp solid border line above the blurred backdrop */
    .message-paragraph::after { content: ""; position: absolute; z-index: -1; pointer-events: none;
      left: -0.6em; right: -0.6em; top: -0.3em; bottom: -0.25em;
      border: var(--msgBackdropBorderWidth, 0px) solid var(--msgBackdropBorderColor, rgba(186,120,72,0.4));
      border-radius: 6px; opacity: var(--msgBackdropOpacity, 0.9); }
    .marquee { position: absolute; left: 0; right: 0; bottom: 6vh; height: 48px; overflow: hidden; opacity: 0.0; }
    /* add a subtle dark band behind the marquee line */
    .marquee::before { content: ""; position: absolute; inset: 0; pointer-events: none; z-index: 0;
      background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.35), rgba(0,0,0,0.55));
      /* Frosted band to obscure visuals behind */
      backdrop-filter: blur(var(--msgFrostPx, 12px)) brightness(var(--msgFrostBright, 0.72)) saturate(var(--msgFrostSat, 0.65));
      -webkit-backdrop-filter: blur(var(--msgFrostPx, 12px)) brightness(var(--msgFrostBright, 0.72)) saturate(var(--msgFrostSat, 0.65)); }
    .marquee-track { position: absolute; white-space: nowrap; will-change: transform; z-index: 1; }
    .marquee span { padding: 0 24px; color: #f1cda2; font-weight: 800;
      font-family: Impact, Haettenschweiler, 'Arial Black', 'Segoe UI Black', sans-serif;
      text-transform: uppercase;
      -webkit-text-stroke: 1px rgba(0,0,0,0.6);
      text-shadow:
        0 2px 2px rgba(0,0,0,0.75),
        0 0 10px rgba(240,170,100,0.35),
        0 0 22px rgba(240,170,100,0.22);
      filter: drop-shadow(0 2px 8px rgba(0,0,0,0.7)); }
    /* Toggle classes from JS */
    .overlay.backdrop-off .message-paragraph::before { display: none; }
    .overlay.band-off .marquee::before { display: none; }
    .overlay.stroke-off .message-paragraph, .overlay.stroke-off .marquee span { -webkit-text-stroke: 0 transparent; }
    .overlay.glow-off .message-paragraph, .overlay.glow-off .marquee span { text-shadow: none; filter: none; }
    /* Border for marquee band when border option enabled */
    .overlay.backdrop-border .marquee::after { content: ""; position: absolute; inset: 0; pointer-events: none; z-index: 2;
      border: var(--msgBackdropBorderWidth, 0px) solid var(--msgBackdropBorderColor, rgba(186,120,72,0.4)); border-radius: 6px; }
    /* Hover/tap to reveal */
    @media (hover:hover) {
      .dock-zone:hover + .panel { bottom: 0; }
    }
    @media (hover:none) {
      .dock-zone { height: 28px; }
    }
    /* YT music search modal */
    .yt-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.55); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: none; align-items: center; justify-content: center; z-index: 3000; }
    .yt-modal-backdrop.show { display: flex; }
    .yt-modal { width: min(880px, 92vw); background: rgba(20,16,12,0.96); border: 1px solid rgba(255,200,150,0.2); border-radius: 10px; box-shadow: 0 20px 60px rgba(0,0,0,0.55); color: #e7c39a; }
    .yt-modal-head { display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; border-bottom: 1px solid rgba(255,200,150,0.18); }
    .yt-modal-body { padding: 12px 14px; }
    /* Always show cursor over the YT modal */
    .yt-modal-backdrop, .yt-modal-backdrop * { cursor: auto !important; }
    /* Video overlay window */
    .video-window { position: fixed; left: 40px; top: 40px; width: 520px; height: 300px; z-index: 2500; border: 1px solid rgba(255,200,150,0.35); border-radius: 8px; overflow: hidden; resize: both; background: rgba(8,6,4,0.2); backdrop-filter: blur(1px); }
    .video-window .chrome { position: absolute; left: 0; right: 0; top: 0; height: 34px; display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: linear-gradient(180deg, rgba(30,24,18,0.9), rgba(20,16,12,0.85)); border-bottom: 1px solid rgba(255,200,150,0.2); color: #e7c39a; cursor: move; user-select: none; }
    .video-window .chrome .title { font-weight: 700; letter-spacing: 0.02em; }
    .video-window .chrome .spacer { flex: 1; }
    .video-window .chrome input[type="range"] { width: 160px; }
    .video-window .content { position: absolute; left: 0; right: 0; top: 34px; bottom: 0; background: #000; display: flex; align-items: center; justify-content: center; }
    .video-window iframe { width: 100%; height: 100%; border: 0; display: block; }
    .video-window.chrome-hidden { border-color: transparent; }
    .video-window.chrome-hidden .chrome { opacity: 0; pointer-events: none; transition: opacity 220ms ease; }
    .video-window:not(.chrome-hidden) .chrome { opacity: 1; transition: opacity 120ms ease; }
    /* Always show cursor over the video window */
    .video-window, .video-window * { cursor: auto !important; }
    .video-window iframe { cursor: auto !important; pointer-events: auto; }
    /* Maximized state: hide chrome and border for full visual coverage */
    .video-window.maximized { border: none; }
    .video-window.maximized .chrome { display: none; }
    .video-window.maximized .content { top: 0; }
    /* Restore button styling */
    #btnRestoreVideo { width: 64px; height: 64px; border-radius: 50%; background: rgba(25,20,15,0.92); border: 1px solid rgba(255,200,150,0.45); color: #e7c39a; font-weight: 900; font-size: 22px; box-shadow: 0 10px 26px rgba(0,0,0,0.6); }
    /* Distinct on/off styles for player toggles */
    #btnShuffle.active, #btnRepeat.active, #btnRepeat1.active {
      background: rgba(255,200,150,0.22);
      border: 1px solid rgba(255,200,150,0.7);
      box-shadow: 0 0 0 2px rgba(255,200,150,0.18) inset, 0 8px 18px rgba(0,0,0,0.45);
      color: #f6dcb8;
      transform: translateY(-1px);
    }
    #btnShuffle.overridden, #btnRepeat.overridden { opacity: 0.35; filter: grayscale(100%); }
    #btnShuffle:disabled, #btnRepeat:disabled { opacity: 0.3 !important; filter: grayscale(100%) !important; cursor: not-allowed; }
    #btnRestoreVideo:hover { transform: translateX(-50%) scale(1.06); }
    /* Dev Settings modal (tiny, top-right, no backdrop) */
    #devModal { position: fixed; top: 8px; right: 12px; bottom: auto; left: auto; width: 320px; max-height: 70vh; overflow: auto; z-index: 9500;
      background: rgba(16,12,9,0.98); border: 1px solid rgba(255,200,150,0.25); border-radius: 8px; color: #e7c39a; display: none; }
    #devModal .head { display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; border-bottom: 1px solid rgba(255,200,150,0.18); }
    #devModal .body { padding: 10px; display: grid; gap: 10px; }
    #devModal .section { border: 1px dashed rgba(255,200,150,0.22); border-radius: 6px; padding: 8px; }
    #devModal label { display:flex; align-items:center; gap:8px; margin: 4px 0; }
    #devModal input[type="text"], #devModal input[type="url"], #devModal input[type="number"], #devModal input[type="color"] {
      width: 100%; background: rgba(30,24,18,0.9); color:#e7c39a; border:1px solid rgba(255,200,150,0.18); border-radius:6px; padding:4px 6px;
    }
    /* Dev modal themed scrollbar */
    #devModal { scrollbar-width: thin; scrollbar-color: rgba(255,200,150,0.45) rgba(30,24,18,0.6); }
    #devModal::-webkit-scrollbar { width: 10px; height: 10px; }
    #devModal::-webkit-scrollbar-track { background: rgba(30,24,18,0.55); border-radius: 8px; box-shadow: inset 0 0 0 1px rgba(255,200,150,0.10); }
    #devModal::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(200,150,100,0.55), rgba(140,95,60,0.65));
      border: 1px solid rgba(255,200,150,0.28);
      border-radius: 8px;
      box-shadow: inset 0 0 0 1px rgba(110,75,48,0.25);
    }
    #devModal::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg, rgba(220,170,120,0.7), rgba(160,110,70,0.75)); }
    /* Fullscreen overlay image effect (centered in scene) */
    #devOverlayImg { position: fixed; inset: 0; pointer-events: none; z-index: 8000; display:none; object-fit: contain; object-position: center center; opacity: 0.5; background: transparent; }
  </style>
  <style>
    /* Force cursor visible when needed */
    .cursor-on, .cursor-on * { cursor: auto !important; }
    body.cursor-on { cursor: auto !important; }
    html.cursor-on { cursor: auto !important; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div class="vignette"></div>
  <div class="overlay">
    <div id="msgParagraph" class="message-paragraph"></div>
    <div class="marquee" id="marquee">
      <div class="marquee-track" id="marqueeTrack"></div>
    </div>
  </div>
  <!-- Draggable/Resizable Video Window Overlay (moved outside overlay for interactivity) -->
  <div id="videoWindow" class="video-window" style="display:none;">
    <div class="chrome" id="videoWinBar">
      <div class="title"></div>
      <div class="spacer"></div>
      <label class="pill" title="Transparency">
        Transparency <input id="videoOpacity" type="range" min="0" max="1" step="0.01" value="0.2" />
      </label>
      <button id="btnMaximizeVideo" title="Maximize over visualizer">🗖</button>
      <button id="btnCloseVideo" title="Close">✖</button>
    </div>
    <div class="content">
      <div id="videoOverlayPlayer" style="width:100%; height:100%;"></div>
      <video id="overlayHtmlVideo" style="position:absolute; inset:0; width:100%; height:100%; display:none; background:#000;" playsinline></video>
      <div id="videoNoContent" style="position:absolute; inset:0; display:none; align-items:center; justify-content:center; color:#e7c39a;">No video for this item</div>
      <button id="btnRestoreVideo" title="Restore window size" style="position:absolute; top:4px; left:50%; transform: translateX(-50%); display:none; z-index:5;">✖</button>
    </div>
  </div>
  <!-- Draggable/Resizable Live Camera Window Overlay (moved outside overlay for interactivity) -->
  <div id="obsWindow" class="video-window" style="display:none; right:40px; left:auto; top:40px;">
    <div class="chrome" id="liveWinBar">
      <div class="title"></div>
      <div class="spacer"></div>
      <label class="pill" title="Transparency">
        Transparency <input id="liveOpacityBar" type="range" min="0" max="1" step="0.01" value="0.2" />
      </label>
      <button id="btnMaximizeLive" title="Maximize over visualizer">🗖</button>
      <button id="btnCloseLive" title="Close">✖</button>
    </div>
    <div class="content">
      <video id="liveVideo" autoplay playsinline muted style="width:100%; height:100%; object-fit:cover; background:#000;"></video>
      <button id="btnRestoreLive" title="Restore window size" style="position:absolute; top:4px; left:50%; transform: translateX(-50%); display:none; z-index:5;">✖</button>
    </div>
  </div>
  <!-- Draggable/Resizable Kick Stream Window (separate, outside overlay) -->
  <div id="kickWindow" class="video-window" style="display:none; right:40px; bottom:40px; left:auto; top:auto;">
    <div class="chrome" id="kickWinBar">
      <div class="title">Kick Stream</div>
      <div class="spacer"></div>
      <label class="pill" title="Transparency">
        Transparency <input id="kickOpacity" type="range" min="0" max="1" step="0.01" value="0.2" />
      </label>
      <button id="btnMaximizeKick" title="Maximize over visualizer">🗖</button>
      <button id="btnCloseKickWin" title="Close">✖</button>
    </div>
    <div class="content">
      <iframe id="kickFrame" title="Kick Stream" allow="autoplay; picture-in-picture" style="width:100%; height:100%; border:0; background:#000;"></iframe>
      <button id="btnRestoreKick" title="Restore window size" style="position:absolute; top:4px; left:50%; transform: translateX(-50%); display:none; z-index:5;">✖</button>
    </div>
  </div>
  <!-- Draggable/Resizable VDO.Ninja Window (separate, outside overlay) -->
  <div id="vdoWindow" class="video-window" style="display:none; left:40px; bottom:40px; top:auto;">
    <div class="chrome" id="vdoWinBar">
      <div class="title">VDO.Ninja</div>
      <div class="spacer"></div>
      <label class="pill" title="Transparency">
        Transparency <input id="vdoOpacity" type="range" min="0" max="1" step="0.01" value="0.2" />
      </label>
      <button id="btnMaximizeVdo" title="Maximize over visualizer">🗖</button>
      <button id="btnCloseVdoWin" title="Close">✖</button>
    </div>
    <div class="content">
      <iframe id="vdoFrame" title="VDO Ninja" allow="autoplay; camera; microphone; display-capture; picture-in-picture" style="width:100%; height:100%; border:0; background:#000;"></iframe>
      <button id="btnRestoreVdo" title="Restore window size" style="position:absolute; top:4px; left:50%; transform: translateX(-50%); display:none; z-index:5;">✖</button>
    </div>
  </div>
  <!-- YouTube Music Search Modal (moved outside overlay for pointer events) -->
  <div class="yt-modal-backdrop" id="ytSearchModal">
    <div class="yt-modal">
      <div class="yt-modal-head">
        <div class="pill">YouTube Music Search</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="ytApiKey" type="password" placeholder="API Key" style="width:220px" />
          <button id="btnSaveApiKey">Save Key</button>
          <button id="btnCloseYtModal">Close</button>
        </div>
      </div>
      <div class="yt-modal-body">
        <div class="row" style="gap:8px;">
          <input id="ytQuery" class="grow" type="text" placeholder="Search music videos..." />
          <button id="btnRunYtSearch">Search</button>
        </div>
        <div id="ytPreview" style="margin-top:10px; display:none;">
          <!-- Embedded preview iframe will appear here -->
        </div>
        <div id="ytResults" class="list" style="margin-top:10px; max-height:260px; overflow:auto;"></div>
        <div class="note" style="opacity:0.75; font-size:12px; margin-top:6px; display:flex; gap:8px; align-items:center;">
          <span>Uses YouTube Data API v3. Provide an API key from Google Cloud Console (enable YouTube Data API v3). Filter: category=Music.</span>
          <button id="btnOpenApiKeyGuide" class="pill" title="Open Google Cloud Console to get an API key">Get an API Key</button>
        </div>
      </div>
    </div>
  </div>
  <div class="dock-zone"></div>
  <div class="panel" id="panel">
    <!-- Top-right compact settings toolbar -->
    <div id="settingsToolbar" style="position:absolute; top:8px; right:12px; display:flex; gap:6px; align-items:center; z-index:1;">
      <button id="btnDev" class="btn-sm" title="Developer/Debug controls">Dev Settings</button>
      <button id="btnPurge" class="btn-sm" title="Clear saved settings">Purge</button>
      <button id="btnExport" type="button" class="btn-sm" title="Export settings to JSON">Export JSON</button>
      <label class="pill btn-sm" id="lblImport" title="Import settings from JSON" style="white-space:nowrap;">Import JSON
        <input id="importJson" type="file" accept="application/json" style="display:none;" />
      </label>
    </div>
    <div class="panel-inner">
      <div class="section" id="playerSection">
        <div class="row" style="justify-content: space-between;">
          <div class="pill">Mode</div>
          <select id="modeSelect">
            <option value="player">Music Player</option>
            <option value="messages">Message Center</option>
            <option value="live">Livestream</option>
          </select>
          <div class="pill" id="captureStatus">Audio: idle</div>
          <div style="flex:1"></div>
          <label class="pill" title="Show message overlay on screen in all modes"><input id="toggleOverlay" type="checkbox" /> Message</label>
          <label class="pill" title="Grow plant stems overlay"><input id="togglePlants" type="checkbox" /> YStems</label>
          <button id="btnSearchYT" title="Search YouTube Music">Search Music</button>
          <button id="btnShowVideo" title="Show video overlay window">Show Video</button>
          <button id="btnCapture">Capture Audio</button>
          <button id="btnReleaseAudio" title="Stop using captured audio and return to idle">Release Audio</button>
          <button id="btnResetVis" title="Reset visualizer (non-destructive)">Reset Visualizer</button>
        </div>
        <!-- Livestream: Controls row (visible only in Livestream mode) -->
        <div class="row" id="liveControlsRow" style="display:none; margin-top:8px; gap:10px; align-items:center;">
          <div class="pill">Camera</div>
          <select id="liveDevice" style="min-width:220px;"></select>
          <button id="liveRefresh">Refresh</button>
          <button id="btnShowLive">Show Live</button>
          <button id="btnNewLive">New Live Window</button>
        </div>
        <div id="liveWindowsList" class="list" style="display:none; max-height:120px; overflow:auto; margin-top:6px; border: 1px solid rgba(255,200,150,0.12); border-radius: 6px; padding: 6px;"></div>
        <!-- Right side content for Livestream mode -->
        <template id="liveRightTemplate">
          <div id="liveRight" class="section">
            <div class="row" style="justify-content: space-between;">
              <div class="pill">Kick.com Livestream</div>
              <div style="opacity:0.7; font-size:12px;">Enter you kick.com stream page URL</div>
            </div>
            <div class="row" style="margin-top:8px; gap:8px; align-items:center;">
              <input id="kickUrl" type="text" class="grow" value="https://kick.com/ninetentwo" />
              <button id="btnOpenKick">Open Kick</button>
              <button id="btnCloseKick">Hide</button>
            </div>
            <hr style="border-color: rgba(255,200,150,0.15); margin:10px 0;"/>
            <div class="row" style="justify-content: space-between;">
              <div class="pill">VDO.Ninja</div>
              <div style="opacity:0.7; font-size:12px;">Enter your VDO.Ninja URL</div>
            </div>
            <div class="row" style="margin-top:8px; gap:8px; align-items:center;">
              <input id="vdoUrl" type="text" class="grow" value="https://vdo.ninja/?view=NfRGiBa" />
              <button id="btnOpenVdoPopup">Open VDO.Ninja</button>
              <button id="btnOpenVdoWin">Open In Window</button>
              <button id="btnCloseVdo">Hide</button>
            </div>
          </div>
        </template>
        <div class="row" style="margin-top:8px; gap:10px;">
          <button id="btnPrev">⏮</button>
          <button id="btnPlay">⏵</button>
          <button id="btnNext">⏭</button>
          <input id="seek" type="range" min="0" max="100" value="0" style="flex:1" />
          <input id="volume" type="range" min="0" max="1" step="0.01" value="0.8" style="width:140px" />
          <button id="btnShuffle" title="Shuffle"><i class="fa-solid fa-shuffle"></i></button>
          <button id="btnRepeat" title="Repeat"><i class="fa-solid fa-rotate-right"></i></button>
          <button id="btnRepeat1" title="Repeat current item only">Repeat 1</button>
        </div>
        <!-- Message Center: Live preview row (visible only in Message Center mode) -->
        <div class="row" id="msgPreviewRow" style="display:none; margin-top:8px;">
          <div id="msgPreviewBox" class="list" style="width:100%; min-height:56px; display:flex; align-items:center; justify-content:center; font-weight:800; letter-spacing:0.02em;">
            Preview will appear here when in Message Center
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <input id="addUrl" class="grow" type="text" placeholder="Paste YouTube URL (video or playlist)" />
          <button id="btnAdd">Add</button>
          <button id="btnAddFile">Add File</button>
          <div id="playlistCounts" class="pill" title="Playlist counts" style="display:inline-flex; align-items:center; gap:8px;">
            <span class="yt" style="display:inline-flex; align-items:center; gap:4px;"><i class="fa-brands fa-youtube"></i><span id="countYT">0</span></span>
            <span class="aud" style="display:inline-flex; align-items:center; gap:4px;"><i class="fa-solid fa-music"></i><span id="countAudio">0</span></span>
            <span class="vid" style="display:inline-flex; align-items:center; gap:4px;"><i class="fa-solid fa-film"></i><span id="countVideo">0</span></span>
            <span class="all" style="display:inline-flex; align-items:center; gap:4px; opacity:0.9;"><i class="fa-solid fa-list"></i><span id="countAll">0</span></span>
          </div>
          <input id="fileInput" type="file" accept="audio/*,video/*,.m3u8" style="display:none;" />
        </div>
        <div id="playlist" class="list" aria-label="playlist"></div>
        <div class="row" style="margin-top:10px; gap:12px; align-items:center;">
          <div class="pill">Sensitivity</div>
          <label class="pill">Bass <input id="sensBass" type="range" min="0" max="2" step="0.01" value="1" /></label>
          <label class="pill">Mid <input id="sensMid" type="range" min="0" max="2" step="0.01" value="1" /></label>
          <label class="pill">Treble <input id="sensTreble" type="range" min="0" max="2" step="0.01" value="1" /></label>
          <label class="pill"><input id="sensPunchy" type="checkbox" /> Punchy</label>
          <label class="pill"><input id="sensThunder" type="checkbox" /> Thunder</label>
          <label class="pill">Thunder <input id="sensThunderIntensity" type="range" min="0" max="2" step="0.01" value="1" /></label>
        </div>
      </div>

      <div class="section" id="messagesSection">
        <div class="row">
          <div class="pill">Messages</div>
          <select id="msgMode">
            <option value="paragraph">Paragraph</option>
            <option value="marqueeH">Marquee Horizontal</option>
            <option value="marqueeV">Marquee Vertical</option>
          </select>
          <button id="btnEditMsg" title="Save current text as a message">Save</button>
          <button id="btnClearMsg">Clear</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <textarea id="msgInput" class="grow" rows="2" placeholder="Message text... (Shift+Enter for new line)"></textarea>
          <button id="btnNewLine" title="Insert line break">New Line</button>
          <input id="msgSize" type="number" min="12" max="128" value="38" title="size" />
          <input id="msgSpeed" type="number" min="10" max="240" value="60" title="speed (px/s)" />
          <label class="pill">Marquee Position
            <select id="msgPos">
              <option value="bottom">Bottom</option>
              <option value="center">Center</option>
              <option value="top">Top</option>
            </select>
          </label>
          <label class="pill">Align
            <select id="msgAlign">
              <option value="left">Left</option>
              <option value="center">Center</option>
              <option value="right">Right</option>
            </select>
          </label>
        </div>
        <div class="row" style="margin-top:8px; gap:12px; align-items:center;">
          <label class="pill">Line Spacing <input id="msgLine" type="range" min="0.8" max="2" step="0.05" value="1.2" /></label>
        </div>
        <div class="row" style="margin-top:8px; gap:12px;">
          <label class="pill"><input id="optBackdrop" type="checkbox" checked /> Backdrop</label>
          <label class="pill"><input id="optBand" type="checkbox" checked /> Marquee Band</label>
          <label class="pill"><input id="optStroke" type="checkbox" checked /> Stroke</label>
          <label class="pill"><input id="optGlow" type="checkbox" checked /> Glow</label>
          <label class="pill"><input id="optBorder" type="checkbox" /> Backdrop Border</label>
        </div>
        <div class="row" style="margin-top:8px; gap:12px; align-items:center;">
          <label class="pill">Backdrop Opacity <input id="optBackdropOpacity" type="range" min="0" max="1" step="0.01" value="0.9" /></label>
          <label class="pill">Backdrop Blur <input id="optBackdropBlur" type="range" min="0" max="20" step="0.5" value="8" /></label>
          <label class="pill">Border Width <input id="optBorderWidth" type="number" min="0" max="8" step="1" value="2" style="width:64px;" /></label>
          <label class="pill">Border Color <input id="optBorderColor" type="color" value="#ba7848" /></label>
        </div>
        <div id="messagesList" class="list" aria-label="messages"></div>
      </div>

      <!-- Dedicated playlist section for right column in Music Player mode -->
      <div class="section" id="playlistSection" style="display:none;">
        <div class="row"><div class="pill">Playlist</div></div>
        <div id="playlistMount"></div>
      </div>
    </div>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
    import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // Scene and camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070707, 0.04);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 6, 10);
    // Store base camera transform for shake effects
    const camBasePos = camera.position.clone();
    const camBaseRot = camera.rotation.clone();

    // Subtle ambient and a moving key light for metallic highlights
    const ambient = new THREE.AmbientLight(0x332214, 0.6);
    scene.add(ambient);
    const keyLight = new THREE.PointLight(0xffb271, 18, 40, 2);
    keyLight.position.set(8, 8, 8);
    scene.add(keyLight);

    // Environment for metal reflections (bronze feel)
    const pmrem = new THREE.PMREMGenerator(renderer);
    const env = new RoomEnvironment();
    const envMap = pmrem.fromScene(env, 0.04).texture;
    scene.environment = envMap;

    // Postprocessing setup (standard composer to ensure compatibility)
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.8, 0.85);
    composer.addPass(bloom);

    const film = new FilmPass(0.25, 0.35, 2048, false);
    composer.addPass(film);

    const smaa = (renderer.capabilities.isWebGL2) ? null : new SMAAPass(window.innerWidth, window.innerHeight);
    if (smaa) composer.addPass(smaa);

    // Subtle motion trailing for extra flow
    const afterimage = new AfterimagePass(0.72); // very subtle trails
    composer.addPass(afterimage);

    // Geometry and bronze material
    const box = new THREE.BoxGeometry(1, 1, 1);
    const bronze = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#a46d3a'),
      metalness: 1.0,
      roughness: 0.35,
      envMapIntensity: 1.2,
      sheen: 0.0,
      iridescence: 0.0,
    });
    // Inject scan hit glow into bronze cubes (lights up when sweep intersects)
    const scanHitUniforms = {
      uTime: { value: 0 },
      uSweepHeight: { value: 10.0 },
      uYaw: { value: 0.15 },
      uScale: { value: 1.0 },        // grid scale for alignment (visual only)
      uThickness: { value: 0.10 },   // line thickness
      uSubThickness: { value: 0.04 },
      uGlow: { value: 2.2 },
      uColor: { value: new THREE.Color('#f0ad72') },
      uBandSharpness: { value: 0.18 } // how tightly the band sticks to the plane
    };
    bronze.onBeforeCompile = (shader) => {
      // Attach uniforms
      shader.uniforms.uTime = scanHitUniforms.uTime;
      shader.uniforms.uSweepHeight = scanHitUniforms.uSweepHeight;
      shader.uniforms.uYaw = scanHitUniforms.uYaw;
      shader.uniforms.uScale = scanHitUniforms.uScale;
      shader.uniforms.uThickness = scanHitUniforms.uThickness;
      shader.uniforms.uSubThickness = scanHitUniforms.uSubThickness;
      shader.uniforms.uGlow = scanHitUniforms.uGlow;
      shader.uniforms.uColor = scanHitUniforms.uColor;
      shader.uniforms.uBandSharpness = scanHitUniforms.uBandSharpness;

      // Vertex: output world position
      shader.vertexShader = shader.vertexShader.replace(
        '#include <common>',
        `#include <common>\n varying vec3 vWorldPos;`
      );
      shader.vertexShader = shader.vertexShader.replace(
        '#include <worldpos_vertex>',
        `#include <worldpos_vertex>\n vWorldPos = worldPosition.xyz;`
      );

      // Fragment: add scan grid band and emissive glow when hit
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <common>',
        `#include <common>\n varying vec3 vWorldPos;\n uniform float uTime; uniform float uSweepHeight; uniform float uYaw;\n uniform float uScale; uniform float uThickness; uniform float uSubThickness;\n uniform float uGlow; uniform vec3 uColor; uniform float uBandSharpness;\n mat3 rotY(float a){ float c=cos(a), s=sin(a); return mat3(c,0.0,-s, 0.0,1.0,0.0, s,0.0,c); }\n float gridLine(float x, float t){ float gx = mod(x, 1.0) - 0.5; float d = abs(gx); float edge = t*0.5; float aa = fwidth(gx) * 1.5; return 1.0 - smoothstep(edge - aa, edge + aa, d); }`
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <emissivemap_fragment>',
        `#include <emissivemap_fragment>\n {
           // Sweeping plane in world space
           float sweep = sin(uTime * 0.22) * 0.5 + 0.5; // 0..1
           float yPos = -uSweepHeight * 0.5 + sweep * uSweepHeight;
           vec3 origin = vec3(0.0, yPos, 0.0);
           mat3 R = rotY(uYaw + sin(uTime * 0.10) * 0.10);
           vec3 n = R * vec3(0.0, 1.0, 0.0);
           vec3 ax = normalize(R * vec3(1.0, 0.0, 0.0));
           vec3 az = normalize(cross(n, ax));
           vec3 d = vWorldPos - origin;
           float u = dot(d, ax) / max(1e-3, uScale);
           float v = dot(d, az) / max(1e-3, uScale);
           float h = dot(d, n);
           float band = exp(-pow(h * (1.0 / max(1e-3, uBandSharpness)), 2.0));
           float p = max(gridLine(u, uThickness), gridLine(v, uThickness));
           float ps = max(gridLine(u*4.0, uSubThickness), gridLine(v*4.0, uSubThickness)) * 0.6;
           float pulse = 0.9 + 0.1 * sin(uTime * 2.0);
           float intensity = (p + ps) * band * uGlow * pulse;
           totalEmissiveRadiance += uColor * intensity; // add glow
         }`
      );
    };
    bronze.needsUpdate = true;

    // Instanced grid with organic motion and depth
    const GRID = 18; // 18^3 = 5832 instances
    const SPACING = 0.7;
    const HALF = (GRID - 1) * SPACING * 0.5;

    const mesh = new THREE.InstancedMesh(box, bronze, GRID * GRID * GRID);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(mesh);

    // --- Additions: Orbiting bronze monoliths ---
    const monolithGroup = new THREE.Group();
    scene.add(monolithGroup);
    const monolithMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#c48854'),
      metalness: 1.0,
      roughness: 0.25,
      envMapIntensity: 1.3
    });
    const MONO_COUNT = 18;
    for (let k = 0; k < MONO_COUNT; k++) {
      const h = 1.2 + Math.random() * 2.0;
      const w = 0.15 + Math.random() * 0.15;
      const d = 0.4 + Math.random() * 0.3;
      const g = new THREE.BoxGeometry(w, h, d);
      const m = new THREE.Mesh(g, monolithMat);
      m.userData = {
        radius: HALF * (0.8 + Math.random() * 1.2),
        speed: 0.15 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        tilt: new THREE.Euler(Math.random()*0.5, Math.random()*0.5, Math.random()*0.5),
        bob: 0.4 + Math.random() * 0.6
      };
      monolithGroup.add(m);
    }

    // --- Additions: Subtle rotating rim light ---
    const rimLight = new THREE.DirectionalLight(0xffe0b0, 0.6);
    rimLight.position.set(-8, 6, -4);
    scene.add(rimLight);

    // --- Additions: Nested wireframe lattice cubes ---
    const latticeGroup = new THREE.Group();
    scene.add(latticeGroup);
    const latticeMaterial = new THREE.LineBasicMaterial({ color: 0x5a3921, transparent: true, opacity: 0.35 });
    const latticeScales = [HALF*0.9, HALF*1.2, HALF*1.6];
    for (const s of latticeScales) {
      const geo = new THREE.BoxGeometry(s*2, s*2, s*2);
      const edges = new THREE.EdgesGeometry(geo);
      const wire = new THREE.LineSegments(edges, latticeMaterial);
      wire.userData = { rotSpeed: (Math.random()*0.2 + 0.05) * (Math.random() < 0.5 ? -1 : 1) };
      latticeGroup.add(wire);
    }

    // --- Additions: Ultra-thin wireframe grid effects ---
    const gridGroup = new THREE.Group();
    scene.add(gridGroup);
    const gridSize = HALF * 3.2;
    const gridDiv = 64;
    const gridColor = 0x6d452a; // bronze-ish
    const g1 = new THREE.GridHelper(gridSize, gridDiv, gridColor, gridColor);
    const g2 = new THREE.GridHelper(gridSize * 1.1, gridDiv, gridColor, gridColor);
    const g3 = new THREE.GridHelper(gridSize * 0.9, gridDiv, gridColor, gridColor);
    [g1, g2, g3].forEach((g, i) => {
      g.material.transparent = true;
      g.material.opacity = 0.13 - i * 0.02;
      g.material.depthWrite = false;
      g.renderOrder = -8;
      gridGroup.add(g);
    });
    g2.rotation.x = Math.PI / 2; // vertical grid
    g3.rotation.z = Math.PI / 2; // another orientation

    // Sparse volumetric bronze lattice (very thin lines)
    const thinGridGroup = new THREE.Group();
    scene.add(thinGridGroup);
    const thinMat = new THREE.LineBasicMaterial({ color: 0x4b2f1b, transparent: true, opacity: 0.22 });
    const ext = HALF * 1.8;
    const linesPerAxis = 8;
    const step = (ext * 2) / (linesPerAxis - 1);
    const positions = [];
    // X-axis lines (vary Z,Y)
    for (let yi = 0; yi < linesPerAxis; yi++) {
      for (let zi = 0; zi < linesPerAxis; zi++) {
        const y = -ext + yi * step;
        const z = -ext + zi * step;
        positions.push(-ext, y, z,  ext, y, z);
      }
    }
    // Y-axis lines
    for (let xi = 0; xi < linesPerAxis; xi++) {
      for (let zi = 0; zi < linesPerAxis; zi++) {
        const x = -ext + xi * step;
        const z = -ext + zi * step;
        positions.push(x, -ext, z,  x, ext, z);
      }
    }
    // Z-axis lines
    for (let xi = 0; xi < linesPerAxis; xi++) {
      for (let yi = 0; yi < linesPerAxis; yi++) {
        const x = -ext + xi * step;
        const y = -ext + yi * step;
        positions.push(x, y, -ext,  x, y, ext);
      }
    }
    const thinGeo = new THREE.BufferGeometry();
    thinGeo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions), 3));
    const thinLines = new THREE.LineSegments(thinGeo, thinMat);
    thinLines.renderOrder = -7;
    thinGridGroup.add(thinLines);
    // Thin grid lines enabled (debug: can be toggled via Ctrl+Alt+2)
    thinGridGroup.visible = true;

    // --- Visible Sweeping Scanner Plane (thick TRON-like lines) ---
    const scan2Uniforms = {
      uTime: { value: 0 },
      uScale: { value: 0.9 },       // smaller = tighter grid
      uThickness: { value: 0.12 },  // thick primary lines
      uSubThickness: { value: 0.05 },
      uGlow: { value: 2.0 },
      uMainColor: { value: new THREE.Color('#E3A76B') },
      uSubColor: { value: new THREE.Color('#6e4226') },
      uOpacity: { value: 1.0 },
    };
    const scan2Vertex = `
      varying vec3 vPos;
      void main(){
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const scan2Fragment = `
      #ifdef GL_OES_standard_derivatives
      #extension GL_OES_standard_derivatives : enable
      #endif
      precision highp float;
      varying vec3 vPos;
      uniform float uTime, uScale, uThickness, uSubThickness, uGlow, uOpacity;
      uniform vec3 uMainColor, uSubColor;

      float gridLine(float x, float t) {
        float gx = mod(x, 1.0) - 0.5;
        float d = abs(gx);
        float edge = t * 0.5;
        float aa = fwidth(gx) * 1.5;
        return 1.0 - smoothstep(edge - aa, edge + aa, d);
      }

      void main(){
        vec2 p = vPos.xz / uScale;
        float lx = gridLine(p.x, uThickness);
        float lz = gridLine(p.y, uThickness);
        float primary = max(lx, lz);
        vec2 ps = p * 4.0;
        float sx = gridLine(ps.x, uSubThickness);
        float sz = gridLine(ps.y, uSubThickness);
        float secondary = max(sx, sz) * 0.6;
        float r = length(vPos.xz);
        float vignette = smoothstep(80.0, 6.0, r);
        float pulse = 0.9 + 0.1 * sin(uTime * 2.2);
        vec3 col = uSubColor * secondary + uMainColor * (primary * uGlow * pulse);
        float alpha = (primary + secondary) * vignette * uOpacity;
        if (alpha <= 0.002) discard;
        gl_FragColor = vec4(col, alpha);
      }
    `;
    const scanner2Mat = new THREE.ShaderMaterial({
      uniforms: scan2Uniforms,
      vertexShader: scan2Vertex,
      fragmentShader: scan2Fragment,
      transparent: true,
      depthWrite: false,
      depthTest: true,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide,
    });
    const scanner2 = new THREE.Mesh(new THREE.PlaneGeometry(200, 200, 1, 1), scanner2Mat);
    scanner2.position.set(0, -HALF * 1.9, 0);
    scanner2.rotation.set(Math.PI / 2.0, 0.18, 0.0);
    scanner2.renderOrder = -9;
    scene.add(scanner2);
    // Align cube scan-hit effect scale/yaw with the visible scanner
    scanHitUniforms.uScale.value = scan2Uniforms.uScale.value;
    scanHitUniforms.uYaw.value = scanner2.rotation.y;

    // --- Depth capture target (RGBA-packed) for geometry-aware scan (works on WebGL1/2) ---
    const depthRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      type: THREE.UnsignedByteType,
      depthBuffer: true,
      stencilBuffer: false,
    });
    const depthMat = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking });

    // --- Postprocess: Geometry-aware scan lines that wrap over objects ---
    const scanWrapUniforms = {
      tDiffuse: { value: null },
      tDepth: { value: depthRT.texture },
      cameraNear: { value: camera.near },
      cameraFar: { value: camera.far },
      projectionMatrixInverse: { value: camera.projectionMatrixInverse.clone() },
      cameraMatrixWorld: { value: camera.matrixWorld.clone() },
      time: { value: 0 },
      // Style
      scale: { value: 1.2 },
      thickness: { value: 0.06 },
      subThickness: { value: 0.022 },
      glow: { value: 1.7 },
      opacity: { value: 0.8 },
      mainColor: { value: new THREE.Color('#d89a5c') },
      subColor: { value: new THREE.Color('#6a3f22') },
      // New: softness & wobble
      gaussWidth: { value: 1.35 },
      noiseAmp: { value: 0.04 },
      noiseFreq: { value: 0.9 },
      wobbleAmp: { value: 0.04 },
      breathe: { value: 0.0 },
      // Animation params
      sweepHeight: { value: HALF * 3.2 },
      yaw: { value: 0.15 },
    };
    const scanWrapVert = `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;
    const scanWrapFrag = `
      #ifdef GL_OES_standard_derivatives
      #extension GL_OES_standard_derivatives : enable
      #endif
      precision highp float;
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform sampler2D tDepth;
      uniform float cameraNear, cameraFar;
      uniform mat4 projectionMatrixInverse;
      uniform mat4 cameraMatrixWorld;
      uniform float time;
      uniform float scale, thickness, subThickness, glow, opacity;
      uniform vec3 mainColor, subColor;
      uniform float sweepHeight;
      uniform float yaw;
      uniform float gaussWidth;
      uniform float noiseAmp;
      uniform float noiseFreq;
      uniform float wobbleAmp;
      uniform float breathe;

      float unpackRGBAToDepth(const vec4 v){
        const vec4 bitShift=vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
        return dot(v, bitShift);
      }
      float readDepth( sampler2D depthSampler, vec2 coord ) {
        vec4 c = texture2D( depthSampler, coord );
        return unpackRGBAToDepth(c);
      }

      // Reconstruct view-space position from depth
      vec3 getViewPosition( vec2 uv, float depth ) {
        float z = depth * 2.0 - 1.0;
        vec4 clip = vec4(uv * 2.0 - 1.0, z, 1.0);
        vec4 view = projectionMatrixInverse * clip;
        view.xyz /= view.w;
        return view.xyz;
      }

      // World position from depth
      vec3 getWorldPosition( vec2 uv ) {
        float depth = readDepth( tDepth, uv );
        vec3 viewPos = getViewPosition( uv, depth );
        vec4 worldPos = cameraMatrixWorld * vec4( viewPos, 1.0 );
        return worldPos.xyz;
      }

      // Grid line function with AA and seam-safe periodicity
      float gridLine(float x, float t) {
        // Tiny bias to avoid sampling exactly on seam
        x += 1e-4;
        // Use fract to keep periodicity stable for negative x as well
        float gx = fract(x) - 0.5;
        float d = abs(gx);
        float edge = t * 0.5;
        float aa = fwidth(gx) * 1.5;
        return 1.0 - smoothstep(edge - aa, edge + aa, d);
      }

      mat3 rotY(float a){
        float c=cos(a), s=sin(a);
        return mat3(c,0.0,-s, 0.0,1.0,0.0, s,0.0,c);
      }

      // Cheap 2D value noise
      float vhash(vec2 p){
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
      }
      float vnoise(vec2 p){
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = vhash(i);
        float b = vhash(i + vec2(1.0, 0.0));
        float c = vhash(i + vec2(0.0, 1.0));
        float d = vhash(i + vec2(1.0, 1.0));
        vec2 u = f*f*(3.0-2.0*f);
        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      void main(){
        vec3 worldPos = getWorldPosition( vUv );

        // Define a sweeping plane in world space
        float sweep = sin(time * 0.25) * 0.5 + 0.5; // 0..1
        float yPos = -sweepHeight * 0.5 + sweep * sweepHeight;
        vec3 origin = vec3(0.0, yPos, 0.0);

        // Plane basis rotated around Y (yaw)
        mat3 R = rotY(yaw + sin(time * 0.12) * 0.08);
        vec3 n = R * vec3(0.0, 1.0, 0.0);
        vec3 ax = normalize(R * vec3(1.0, 0.0, 0.0));
        vec3 az = normalize(cross(n, ax));

        // Project world point onto plane space
        vec3 d = worldPos - origin;
        float u = dot(d, ax) / max(1e-3, scale);
        float v = dot(d, az) / max(1e-3, scale);
        // Apply small constant offsets so seam never aligns with camera axes
        u += 0.173; v += 0.117;

        // Add subtle wobble and noise-based jitter in plane space
        float tN = time * 0.3;
        float wobU = sin((u+v) * 1.6 + time*1.3) * wobbleAmp;
        float wobV = cos((u-v) * 1.4 + time*1.1) * wobbleAmp;
        float nU = (vnoise(vec2(u, v) * noiseFreq + tN) - 0.5) * 2.0 * noiseAmp;
        float nV = (vnoise(vec2(v, u) * (noiseFreq*1.1) - tN) - 0.5) * 2.0 * noiseAmp;
        u += wobU + nU;
        v += wobV + nV;

        // Only show lines near the plane (soft band)
        float h = dot(d, n);
        float band = exp(-pow(h * 0.15, 2.0));

        // Primary and secondary grid with cross falloff to avoid full-height/width bands
        // Gaussian width is audio-driven via 'breathe'
        float gw = max(0.6, gaussWidth * (1.0 + breathe));
        float fu = exp(-pow(v * gw, 2.0));
        float fv = exp(-pow(u * gw, 2.0));
        float th = thickness * (1.0 + 0.35 * breathe);
        float sth = subThickness * (1.0 + 0.25 * breathe);
        float lu = gridLine(u, th);
        float lv = gridLine(v, th);
        float p = max(lu * fu, lv * fv);
        float lsu = gridLine(u*4.0, sth);
        float lsv = gridLine(v*4.0, sth);
        float ps = max(lsu * fu, lsv * fv) * 0.55;

        float lines = (p + ps) * band;
        float pulse = 0.85 + 0.15 * sin(time * 2.0);
        vec3 col = subColor * (ps) + mainColor * (p * glow * pulse);

        vec4 base = texture2D( tDiffuse, vUv );
        vec3 outCol = base.rgb + col * lines * opacity;
        gl_FragColor = vec4(outCol, base.a);
      }
    `;
    let scanWrapPass = null;
    const scanWrapDef = {
      uniforms: scanWrapUniforms,
      vertexShader: scanWrapVert,
      fragmentShader: scanWrapFrag
    };
    // Always enable (uses RGBA-packed depth target, no special extension needed)
    const depthOK = true;
    if (depthOK) {
      scanWrapPass = new ShaderPass(scanWrapDef);
      composer.addPass(scanWrapPass);
    } else {
      console.warn('Scan wrap pass disabled for compatibility.');
    }

    // Final output
    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // --- Additions: Bronze shard swarm (replaces rings) ---
    const SHARD_COUNT = 220;
    const shardGeom = new THREE.BoxGeometry(1, 1, 1);
    const shardMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#bb7f4c'),
      metalness: 1.0,
      roughness: 0.35,
      envMapIntensity: 1.2
    });
    const shards = new THREE.InstancedMesh(shardGeom, shardMat, SHARD_COUNT);
    shards.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(shards);
    const shardParams = new Float32Array(SHARD_COUNT * 6); // radius, heightAmp, speed, phase, tiltX, tiltY
    const shardTmp = new THREE.Object3D();
    for (let s = 0; s < SHARD_COUNT; s++) {
      const r = HALF * (0.6 + Math.random() * 1.4);
      const hA = 0.8 + Math.random() * 2.2;
      const sp = 0.2 + Math.random() * 0.6;
      const ph = Math.random() * Math.PI * 2;
      const tx = (Math.random() - 0.5) * 0.6;
      const ty = (Math.random() - 0.5) * 0.6;
      shardParams[s*6+0] = r;
      shardParams[s*6+1] = hA;
      shardParams[s*6+2] = sp;
      shardParams[s*6+3] = ph;
      shardParams[s*6+4] = tx;
      shardParams[s*6+5] = ty;
      // initial transform
      const ang = ph;
      shardTmp.position.set(Math.cos(ang)*r, Math.sin(ph*1.3)*hA, Math.sin(ang)*r);
      const sx = 0.04 + Math.random()*0.22;
      const sy = 0.25 + Math.random()*0.7;
      const sz = 0.04 + Math.random()*0.22;
      shardTmp.scale.set(sx, sy, sz);
      shardTmp.rotation.set(tx, ty, ph);
      shardTmp.updateMatrix();
      shards.setMatrixAt(s, shardTmp.matrix);
    }

    // --- Additions: Spiral particle streamers ---
    const STREAM_COUNT = 2;
    const STREAM_POINTS = 1400;
    const streamerGroup = new THREE.Group();
    scene.add(streamerGroup);
    for (let s = 0; s < STREAM_COUNT; s++) {
      const geom = new THREE.BufferGeometry();
      const pos = new Float32Array(STREAM_POINTS * 3);
      for (let i = 0; i < STREAM_POINTS; i++) {
        const t = i / STREAM_POINTS;
        const a = t * Math.PI * 8 + (s * Math.PI);
        const r = HALF * (0.3 + 0.6 * t);
        pos[i*3+0] = Math.cos(a) * r;
        pos[i*3+1] = (t - 0.5) * HALF * 1.6;
        pos[i*3+2] = Math.sin(a) * r;
      }
      geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.LineBasicMaterial({ color: 0x8a5a34, transparent: true, opacity: 0.22 });
      const line = new THREE.Line(geom, mat);
      line.userData = { rot: (s===0?1:-1) * 0.0025 };
      line.renderOrder = -6;
      streamerGroup.add(line);
    }

    // --- Additions: Expanding pulse shells ---
    const pulseGroup = new THREE.Group();
    scene.add(pulseGroup);
    const pulseMat = new THREE.MeshBasicMaterial({ color: 0xCB8A4E, transparent: true, opacity: 0.0, blending: THREE.AdditiveBlending, depthWrite: false });
    const pulseGeo = new THREE.SphereGeometry(1, 32, 32);
    const pulses = [];
    function spawnPulse() {
      const mesh = new THREE.Mesh(pulseGeo, pulseMat.clone());
      mesh.scale.setScalar(0.1);
      mesh.material.opacity = 0.0;
      pulseGroup.add(mesh);
      pulses.push({ mesh, t: 0, maxR: HALF * 2.0, speed: 0.45 + Math.random() * 0.25 });
    }
    // seed a couple of pulses
    spawnPulse();
    setTimeout(spawnPulse, 1200);

    // Per-instance random seeds for motion and scale variability
    const seeds = new Float32Array(mesh.count * 4);
    const tmp = new THREE.Object3D();

    let i = 0;
    for (let x = 0; x < GRID; x++) {
      for (let y = 0; y < GRID; y++) {
        for (let z = 0; z < GRID; z++) {
          const px = x * SPACING - HALF;
          const py = y * SPACING - HALF;
          const pz = z * SPACING - HALF;

          const s = 0.35 + Math.random() * 0.15; // base tiny cube, grows via animation
          tmp.position.set(px, py, pz);

          tmp.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
          tmp.updateMatrix();
          mesh.setMatrixAt(i, tmp.matrix);

          seeds[i * 4 + 0] = Math.random() * 1000.0; // phase
          seeds[i * 4 + 1] = Math.random() * 2.0 + 0.5; // speed
          seeds[i * 4 + 2] = Math.random() * 0.8 + 0.2; // amplitude
          seeds[i * 4 + 3] = Math.random(); // skew
          i++;
        }
      }
    }

    // Simple pseudo-noise function in JS
    function hash(n) { return (Math.sin(n) * 43758.5453) % 1; }
    function noise3(x, y, z) {
      const i = Math.floor(x), j = Math.floor(y), k = Math.floor(z);
      const fx = x - i, fy = y - j, fz = z - k;
      const u = fx * fx * (3 - 2 * fx);
      const v = fy * fy * (3 - 2 * fy);
      const w = fz * fz * (3 - 2 * fz);
      function h(a, b, c) { return hash(a * 157.0 + b * 113.0 + c * 199.0); }
      const n000 = h(i, j, k), n100 = h(i+1, j, k), n010 = h(i, j+1, k), n110 = h(i+1, j+1, k);
      const n001 = h(i, j, k+1), n101 = h(i+1, j, k+1), n011 = h(i, j+1, k+1), n111 = h(i+1, j+1, k+1);
      const nx00 = n000 * (1 - u) + n100 * u;
      const nx10 = n010 * (1 - u) + n110 * u;
      const nx01 = n001 * (1 - u) + n101 * u;
      const nx11 = n011 * (1 - u) + n111 * u;
      const nxy0 = nx00 * (1 - v) + nx10 * v;
      const nxy1 = nx01 * (1 - v) + nx11 * v;
      return nxy0 * (1 - w) + nxy1 * w;
    }

    // Animation clock
    const clock = new THREE.Clock();
    let prevT = 0;

    // Camera drift path parameters
    let tAccum = 0;

    // --- Background: Bronze embers (particle field) ---
    const EMBER_COUNT = 3000;
    const emberGeometry = new THREE.BufferGeometry();
    const emberPositions = new Float32Array(EMBER_COUNT * 3);
    const emberSizes = new Float32Array(EMBER_COUNT);
    const emberColor = new THREE.Color('#b67a44');
    const radius = HALF * 3.2;
    for (let i = 0; i < EMBER_COUNT; i++) {
      // Uniformly distribute on a thick spherical shell
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = radius * (0.75 + Math.random() * 0.5);
      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);
      emberPositions[i * 3 + 0] = x;
      emberPositions[i * 3 + 1] = y;
      emberPositions[i * 3 + 2] = z;
      emberSizes[i] = 4.0 + Math.random() * 10.0;
    }
    emberGeometry.setAttribute('position', new THREE.BufferAttribute(emberPositions, 3));
    emberGeometry.setAttribute('size', new THREE.BufferAttribute(emberSizes, 1));
    const emberMaterial = new THREE.PointsMaterial({
      color: emberColor,
      size: 6.0,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.5,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const embers = new THREE.Points(emberGeometry, emberMaterial);
    embers.renderOrder = -10; // ensure it stays behind most elements
    scene.add(embers);

    // --- Background: Animated bronze nebula plane (shader) ---
    const bgUniforms = {
      uTime: { value: 0 },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uColorA: { value: new THREE.Color('#120a07') },
      uColorB: { value: new THREE.Color('#2a160e') },
      uColorC: { value: new THREE.Color('#7a4b28') },
      uOpacity: { value: 0.22 }
    };
    const bgVertex = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const bgFragment = `
      precision highp float;
      varying vec2 vUv;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec3 uColorA, uColorB, uColorC;
      uniform float uOpacity;

      // 2D noise (iq)
      float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
      float noise(in vec2 p){
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f*f*(3.0-2.0*f);
        float a = hash(i + vec2(0.0,0.0));
        float b = hash(i + vec2(1.0,0.0));
        float c = hash(i + vec2(0.0,1.0));
        float d = hash(i + vec2(1.0,1.0));
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
      }
      float fbm(vec2 p){
        float f = 0.0;
        float a = 0.5;
        for(int i=0;i<5;i++){
          f += a * noise(p);
          p *= 2.02;
          a *= 0.5;
        }
        return f;
      }

      void main(){
        // Centered coordinates
        vec2 uv = (vUv - 0.5) * vec2(uResolution.x/uResolution.y, 1.0);
        float t = uTime * 0.05;
        float n = fbm(uv * 1.6 + vec2(t*0.8, -t*0.6));
        float m = fbm(uv * 0.9 - vec2(t*0.3, t*0.2));
        float v = smoothstep(0.15, 0.85, n*0.7 + m*0.6);
        vec3 col = mix(uColorA, uColorB, v);
        col = mix(col, uColorC, smoothstep(0.6, 1.0, v));
        // Slight vignette to keep focus
        float r = length(uv);
        float vig = smoothstep(1.1, 0.2, r);
        col *= vig;
        gl_FragColor = vec4(col, uOpacity);
      }
    `;
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: bgUniforms,
      vertexShader: bgVertex,
      fragmentShader: bgFragment,
      depthWrite: false,
      depthTest: false,
      transparent: true
    });
    const bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100, 1, 1), bgMaterial);
    bgPlane.position.set(0, 0, -HALF * 3.2);
    bgPlane.renderOrder = -20; // render furthest back
    scene.add(bgPlane);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableZoom = true; // wheel / pinch zoom
    controls.enablePan = false; // no lateral panning
    controls.enableRotate = true; // mouse drag / touch rotate
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.6;
    controls.target.set(0, 0, 0);
    controls.minDistance = 3.0;
    controls.maxDistance = 30.0;
    controls.zoomSpeed = 0.12; // finer wheel/pinch steps
    controls.zoomToCursor = true; // precise zooming toward cursor
    controls.autoRotate = true; // idle drift handled by controls
    controls.autoRotateSpeed = 0.35; // subtle
    controls.saveState(); // remember the original distance/orientation

    // Touch gestures: 1 finger rotates, 2 fingers dolly; pan stays disabled
    controls.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN
    };

    // Interaction state: pause auto-rotate while user interacts
    let userInteracting = false;
    let resumeTimer = 0;
    function scheduleResume(delay = 800) {
      if (resumeTimer) clearTimeout(resumeTimer);
      resumeTimer = setTimeout(() => { userInteracting = false; }, delay);
    }
    controls.addEventListener('start', () => { userInteracting = true; if (resumeTimer) { clearTimeout(resumeTimer); resumeTimer = 0; } });
    controls.addEventListener('end',   () => { scheduleResume(900); });
    renderer.domElement.addEventListener('wheel', () => { userInteracting = true; scheduleResume(600); }, { passive: true });
    renderer.domElement.addEventListener('touchstart', () => { userInteracting = true; if (resumeTimer) { clearTimeout(resumeTimer); resumeTimer = 0; } }, { passive: true });
    renderer.domElement.addEventListener('touchend',   () => { scheduleResume(900); }, { passive: true });

    // Quick reset to original framing
    renderer.domElement.addEventListener('dblclick', () => { controls.reset(); userInteracting = false; }, { passive: true });
    window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'r') { controls.reset(); userInteracting = false; } });
    // Double-tap to reset on mobile
    let lastTap = 0;
    renderer.domElement.addEventListener('touchend', (e) => {
      const now = performance.now();
      if (now - lastTap < 300) { controls.reset(); userInteracting = false; }
      lastTap = now;
    }, { passive: true });

    // Resize handler
    function onResize() {
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h; camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      composer.setSize(w, h);
      depthRT.setSize(w, h);
      bloom.setSize(w, h);
      bgUniforms.uResolution.value.set(w, h);
      // Update scan pass matrices on resize
      if (scanWrapPass) {
        scanWrapUniforms.projectionMatrixInverse.value.copy(camera.projectionMatrixInverse);
        scanWrapUniforms.cameraMatrixWorld.value.copy(camera.matrixWorld);
      }
      // Plants overlay resize
      if (plantsRenderer) {
        plantsRenderer.setSize(w, h);
      }
      if (plantsOrtho) {
        plantsOrtho.left = 0; plantsOrtho.right = w; plantsOrtho.top = 0; plantsOrtho.bottom = h; plantsOrtho.updateProjectionMatrix();
      }
    }
    window.addEventListener('resize', onResize);
    // Debug hotkeys to identify static line source: Ctrl+Alt+1/2/3 toggle groups
    window.addEventListener('keydown', (e) => {
      if (!e.ctrlKey || !e.altKey) return;
      if (e.key === '1') { latticeGroup.visible = !latticeGroup.visible; console.log('latticeGroup.visible =', latticeGroup.visible); }
      if (e.key === '2') { thinGridGroup.visible = !thinGridGroup.visible; console.log('thinGridGroup.visible =', thinGridGroup.visible); }
      if (e.key === '3') { streamerGroup.visible = !streamerGroup.visible; console.log('streamerGroup.visible =', streamerGroup.visible); }
      if (e.key === '4') { gridGroup.visible = !gridGroup.visible; console.log('gridGroup.visible =', gridGroup.visible); }
      if (e.key === '5') { try { scanner2.visible = !scanner2.visible; console.log('scanner2.visible =', scanner2.visible); } catch(err) { console.warn('scanner2 toggle failed', err); } }
      if (e.key === '6') {
        try {
          const newVis = !scanner2.visible; scanner2.visible = newVis;
          if (typeof scanWrapPass !== 'undefined' && scanWrapPass) {
            scanWrapPass.enabled = newVis; // toggle the post grid wrap pass too
          }
          console.log('Scan effects visibility set to', newVis);
        } catch(err) {
          console.warn('scan effects toggle failed', err);
        }
      }
      if (e.key === '0') {
        // Toggle all THREE.Line and THREE.LineSegments visibility
        const toggleTo = (window.__allLinesHidden = !window.__allLinesHidden);
        let count = 0;
        scene.traverse((obj) => {
          if (obj.isLine || obj.type === 'LineSegments') { obj.visible = !toggleTo; count++; }
        });
        console.log(`All line objects now ${toggleTo ? 'hidden' : 'visible'} (affected ${count})`);
      }
    });

    // Subtle mouse parallax on the key light and camera target for extra depth
    const mouse = new THREE.Vector2(0, 0);
    window.addEventListener('pointermove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = (e.clientY / window.innerHeight) * 2 - 1;
    }, { passive: true });

    // --- Additions: Close-range glowing fireflies ---
    const FIREFLY_COUNT = 500;
    const fireflyGeom = new THREE.BufferGeometry();
    const fireflyPos = new Float32Array(FIREFLY_COUNT * 3);
    const fireflySeeds = new Float32Array(FIREFLY_COUNT * 3);
    const fireflyRadius = HALF * 0.9;
    for (let i = 0; i < FIREFLY_COUNT; i++) {
      // Start within a central sphere
      let x, y, z; do {
        x = (Math.random() * 2 - 1);
        y = (Math.random() * 2 - 1);
        z = (Math.random() * 2 - 1);
      } while (x*x + y*y + z*z > 1);
      const r = fireflyRadius * Math.cbrt(Math.random());
      fireflyPos[i*3+0] = x * r;
      fireflyPos[i*3+1] = y * r;
      fireflyPos[i*3+2] = z * r;
      fireflySeeds[i*3+0] = Math.random() * 1000;
      fireflySeeds[i*3+1] = 0.2 + Math.random() * 0.8; // speed
      fireflySeeds[i*3+2] = Math.random() * Math.PI * 2; // phase
    }
    fireflyGeom.setAttribute('position', new THREE.BufferAttribute(fireflyPos, 3));
    const fireflyMat = new THREE.PointsMaterial({
      color: new THREE.Color('#ffcc88'),
      size: 0.06,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.85,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const fireflies = new THREE.Points(fireflyGeom, fireflyMat);
    fireflies.renderOrder = 5;
    scene.add(fireflies);

    // --- Thunder lightning strikes (blocky right-angled) ---
    const lightningGroup = new THREE.Group();
    scene.add(lightningGroup);
    const STRIKE_POOL = 10;
    const lightningPool = [];
    const strikeMat = new THREE.MeshBasicMaterial({ color: 0xffc48a, transparent: true, opacity: 0.0, blending: THREE.AdditiveBlending, depthWrite: false });
    const segGeoX = new THREE.BoxGeometry(1.4, 0.08, 0.08);
    const segGeoY = new THREE.BoxGeometry(0.08, 1.4, 0.08);
    const segGeoZ = new THREE.BoxGeometry(0.08, 0.08, 1.4);
    function makeStrikeGroup() {
      const g = new THREE.Group();
      // Build a few orthogonal segments in an L/Z-like pattern
      const segs = [];
      for (let i=0; i<6; i++) {
        const axis = i % 3; // cycle X,Y,Z for right-angles
        const geo = axis===0? segGeoX : axis===1? segGeoY : segGeoZ;
        const m = new THREE.Mesh(geo, strikeMat.clone());
        m.position.set(0, i*0.9, 0); // stepped upward a bit
        g.add(m);
        segs.push(m);
      }
      g.userData = { active:false, life:0, ttl:0, vel:new THREE.Vector3(), segs };
      return g;
    }
    for (let i=0;i<STRIKE_POOL;i++){ const g=makeStrikeGroup(); lightningPool.push(g); lightningGroup.add(g); }
    function spawnStrike(intensity){
      const g = lightningPool.find(s => !s.userData.active);
      if (!g) return;
      g.userData.active = true;
      g.userData.life = 0;
      g.userData.ttl = 0.25 + Math.random()*0.20; // very fast
      // Start around top region, random side
      const r = 6 + Math.random()*6;
      const side = Math.floor(Math.random()*4);
      const y = 3.5 + Math.random()*3.0;
      const pos = new THREE.Vector3(
        side===0? -r : side===1? r : (Math.random()*2-1)*r*0.3,
        y,
        side===2? -r : side===3? r : (Math.random()*2-1)*r*0.3
      );
      g.position.copy(pos);
      // Velocity towards center-ish with some lateral
      const dir = new THREE.Vector3(-pos.x, -0.6, -pos.z).normalize();
      dir.x += (Math.random()*2-1)*0.35; dir.z += (Math.random()*2-1)*0.35; dir.y += (Math.random()*2-1)*0.15;
      dir.normalize();
      g.userData.vel.copy(dir.multiplyScalar(8 + intensity*6));
      // Randomize segment offsets for blocky look
      g.userData.segs.forEach((m, idx)=>{
        m.material.opacity = 0.0;
        m.position.x = (Math.random()*2-1) * 0.8;
        m.position.z = (Math.random()*2-1) * 0.8;
        m.rotation.set(0, 0, 0);
      });
      // Update re-add button availability
      btnReaddLocal.disabled = !lastLocalFileName;
    }

    // Main animation loop
    function animate() {
      const t = clock.getElapsedTime();
      const dt = t - prevT; prevT = t;
      tAccum += 0.003;

      // Evolve key light around the scene on a Lissajous-like path
      keyLight.position.set(
        Math.cos(t * 0.7) * 10.0,
        Math.sin(t * 0.5) * 8.0 + 2.0,
        Math.sin(t * 0.9) * 10.0
      );

      // Rim light slow orbit for highlights
      rimLight.position.x = Math.cos(t * 0.3 + 1.2) * 12.0;
      rimLight.position.y = 7.0 + Math.sin(t * 0.4) * 2.0;
      rimLight.position.z = Math.sin(t * 0.3 + 0.8) * 12.0;
      rimLight.target.position.set(0, 0, 0);
      scene.add(rimLight.target);

      // Smooth idle drift handled by controls when not interacting
      controls.autoRotate = !userInteracting;
      controls.update();

      // Animate instanced blocks with flowing noise to create "breathing" architecture
      const mat = new THREE.Matrix4();
      const q = new THREE.Quaternion();
      const v3 = new THREE.Vector3();

      let idx = 0;
      for (let x = 0; x < GRID; x++) {
        for (let y = 0; y < GRID; y++) {
          for (let z = 0; z < GRID; z++) {
            const px = x * SPACING - HALF;
            const py = y * SPACING - HALF;
            const pz = z * SPACING - HALF;

            const s0 = 0.35;
            const phase = seeds[idx * 4 + 0];
            const speed = seeds[idx * 4 + 1];
            const amp = seeds[idx * 4 + 2];
            const skew = seeds[idx * 4 + 3];

            // Field noise modulates scale and rotation
            const n = noise3(px * 0.35 + t * 0.2 * speed + phase, py * 0.35 + t * 0.22 * speed, pz * 0.35 + t * 0.18 * speed);
            const grow = THREE.MathUtils.smoothstep(n, 0.25, 0.75);

            const sx = s0 * (0.5 + amp * 1.8 * grow);
            const sy = s0 * (0.5 + amp * 1.8 * (1.0 - grow) + 0.1 * Math.sin(t + skew * Math.PI * 2.0));
            const sz = s0 * (0.5 + amp * 1.8 * grow);

            v3.set(px, py, pz);
            q.setFromEuler(new THREE.Euler(
              (n * Math.PI * 2.0) + skew * 0.5,
              (n * Math.PI * 1.5) - skew * 0.5,
              Math.sin(t * 0.8 + phase) * 0.2
            ));
            mat.compose(v3, q, new THREE.Vector3(sx, sy, sz));
            mesh.setMatrixAt(idx, mat);
            idx++;
          }
        }
      }
      mesh.instanceMatrix.needsUpdate = true;

      // Animate monoliths
      monolithGroup.children.forEach((m, idx) => {
        const u = m.userData;
        const ang = u.phase + t * u.speed;
        const y = Math.sin(t * 0.9 + idx) * u.bob;
        m.position.set(Math.cos(ang) * u.radius, y, Math.sin(ang) * u.radius);
        m.rotation.x += 0.003 + idx * 0.0001;
        m.rotation.y += 0.004 + idx * 0.00013;
      });

      // Lattice gentle rotation
      latticeGroup.children.forEach((wire, i) => {
        wire.rotation.y += wire.userData.rotSpeed * 0.003;
        wire.rotation.x += (i%2===0?1:-1) * 0.0015;
      });

      // Subtle motion on wireframe grids
      gridGroup.rotation.y += 0.0004;
      thinGridGroup.rotation.x += 0.0002;
      thinGridGroup.rotation.y -= 0.00015;

      // Update scan wrap uniforms (geometry-aware)
      if (scanWrapPass) {
        scanWrapUniforms.time.value = t;
        scanWrapUniforms.sweepHeight.value = HALF * 3.2;
        scanWrapUniforms.yaw.value = 0.15;
        scanWrapUniforms.cameraNear.value = camera.near;
        scanWrapUniforms.cameraFar.value = camera.far;
        scanWrapUniforms.projectionMatrixInverse.value.copy(camera.projectionMatrixInverse);
        scanWrapUniforms.cameraMatrixWorld.value.copy(camera.matrixWorld);
      }

      // Animate visible scanner plane sweep
      scan2Uniforms.uTime.value = t;
      const sweepH = HALF * 3.4;
      const s2 = (Math.sin(t * 0.12) * 0.5 + 0.5);
      scanner2.position.y = -sweepH * 0.5 + s2 * sweepH;
      scanner2.rotation.y = 0.18 + Math.sin(t * 0.1) * 0.1;

      // Sync cube scan-hit glow with the same sweep
      // The cube shader uses sin(uTime * 0.22). To match 0.12 above, scale time by 0.12/0.22.
      scanHitUniforms.uTime.value = t * 0.54545;
      scanHitUniforms.uSweepHeight.value = sweepH;
      scanHitUniforms.uYaw.value = 0.18; // base yaw; shader adds subtle time wobble

      // Bronze shard swarm animation
      {
        const mat = new THREE.Matrix4();
        const q = new THREE.Quaternion();
        const v = new THREE.Vector3();
        for (let s = 0; s < SHARD_COUNT; s++) {
          const r = shardParams[s*6+0];
          const hA = shardParams[s*6+1];
          const sp = shardParams[s*6+2];
          const ph = shardParams[s*6+3];
          const tx = shardParams[s*6+4];
          const ty = shardParams[s*6+5];
          const ang = ph + t * sp;
          const y = Math.sin(t * (0.6 + sp*0.8) + ph) * hA;
          v.set(Math.cos(ang)*r, y, Math.sin(ang)*r);
          q.setFromEuler(new THREE.Euler(tx + Math.sin(t*0.8+ph)*0.2, ty + Math.cos(t*0.7+ph)*0.2, ang*0.2));
          mat.compose(v, q, new THREE.Vector3(1,1,1));
          shards.setMatrixAt(s, mat);
        }
        shards.instanceMatrix.needsUpdate = true;
      }

      // Streamer gentle rotation and shimmer
      streamerGroup.children.forEach((line) => {
        line.rotation.y += line.userData.rot;
        if (line.material && line.material.opacity !== undefined) {
          line.material.opacity = 0.16 + 0.08 * (0.5 + 0.5 * Math.sin(t * 0.6));
        }
      });

      // Pulse shells: spawn and update
      if (!window.__nextPulseAt) {
        window.__nextPulseAt = t + 2.0 + Math.random() * 2.0;
      }
      if (t > window.__nextPulseAt) {
        spawnPulse();
        window.__nextPulseAt = t + 2.0 + Math.random() * 2.5;
      }
      for (let i = pulses.length - 1; i >= 0; i--) {
        const p = pulses[i];
        p.t += dt;
        const u = THREE.MathUtils.smoothstep(p.t * p.speed, 0.0, 1.0);
        const radius = THREE.MathUtils.lerp(0.1, p.maxR, u);
        const fade = (1.0 - THREE.MathUtils.smoothstep(u, 0.6, 1.0)) * 0.28;
        p.mesh.scale.setScalar(Math.max(0.001, radius));
        p.mesh.material.opacity = fade;
        if (u >= 1.0 || fade <= 0.002) {
          pulseGroup.remove(p.mesh);
          p.mesh.geometry.dispose?.();
          p.mesh.material.dispose?.();
          pulses.splice(i, 1);
        }
      }

      // Subtle bronze shimmer via exposure oscillation
      renderer.toneMappingExposure = 1.2 + Math.sin(t * 0.2) * 0.06;

      // Adaptive visibility: reduce fog and ember intensity when zoomed out
      const dist = camera.position.distanceTo(controls.target);
      const baseFog = 0.04;
      const fogScale = 10.0 / Math.max(6.0, dist);
      scene.fog.density = THREE.MathUtils.clamp(baseFog * fogScale, 0.012, 0.05);
      // Fade embers slightly with distance so they don't overpower the subject
      const emberFade = THREE.MathUtils.smoothstep(dist, 12.0, 28.0);
      emberMaterial.opacity = THREE.MathUtils.lerp(0.5, 0.18, emberFade);

      // Background updates
      bgUniforms.uTime.value = t;
      embers.rotation.y += 0.0006; // slow drift spin
      embers.rotation.x += 0.0002;

      // Firefly drift using simple trigonometric flow, keep within central bounds
      {
        const p = fireflyGeom.attributes.position.array;
        for (let i = 0; i < FIREFLY_COUNT; i++) {
          const ix = i*3;
          const seed = fireflySeeds[i*3+0];
          const speed = fireflySeeds[i*3+1];
          const ph = fireflySeeds[i*3+2];
          const vx = Math.sin(t*0.7*speed + seed) * 0.003 + Math.cos(t*0.9*speed + ph) * 0.002;
          const vy = Math.cos(t*0.5*speed + seed*0.7) * 0.003 + Math.sin(t*1.1*speed + ph*0.8) * 0.002;
          const vz = Math.sin(t*0.8*speed + seed*1.3) * 0.003 + Math.cos(t*0.6*speed + ph*1.1) * 0.002;
          p[ix+0] += vx;
          p[ix+1] += vy;
          p[ix+2] += vz;
          // Soft boundary wrap
          const rr = Math.max(1e-3, fireflyRadius*0.95);
          let dx = p[ix+0], dy = p[ix+1], dz = p[ix+2];
          const d2 = dx*dx + dy*dy + dz*dz;
          if (d2 > rr*rr) {
            const d = Math.sqrt(d2);
            const s = rr / d;
            p[ix+0] *= s;
            p[ix+1] *= s;
            p[ix+2] *= s;
          }
        }
        fireflyGeom.attributes.position.needsUpdate = true;
      }

      // Lightning strikes
      lightningPool.forEach((g) => {
        if (g.userData.active) {
          g.userData.life += dt;
          g.position.add(g.userData.vel.multiplyScalar(dt));
          g.userData.segs.forEach((m) => {
            m.material.opacity = Math.max(0.0, 1.0 - g.userData.life / g.userData.ttl);
          });
          if (g.userData.life >= g.userData.ttl) {
            g.userData.active = false;
          }
        }
      });

      // Render scene depth into RGBA depthRT (for scan wrapping)
      if (scanWrapPass) {
        const prev = scene.overrideMaterial;
        scene.overrideMaterial = depthMat;
        renderer.setRenderTarget(depthRT);
        renderer.clear();
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);
        scene.overrideMaterial = prev;
      }

      composer.render();
      requestAnimationFrame(animate);
    }

    // Gentle entrance
    (function intro() {
      renderer.toneMappingExposure = 0.0;
      const start = performance.now();
      function step() {
        const e = (performance.now() - start) / 1600;
        renderer.toneMappingExposure = THREE.MathUtils.lerp(renderer.toneMappingExposure, 1.2, 0.08);
        if (e < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    })();

    // ===== Dev Settings wiring =====
    ;(function(){
      const btnDev = document.getElementById('btnDev');
      const devModal = document.getElementById('devModal');
      const btnDevClose = document.getElementById('btnDevClose');
      const devShowScanner = document.getElementById('devShowScanner');
      const devShowBlockGrid = document.getElementById('devShowBlockGrid');
      const devShowBlockScans = document.getElementById('devShowBlockScans');
      const devShowMonoliths = document.getElementById('devShowMonoliths');
      const devShowShards = document.getElementById('devShowShards');
      const devShowLattice = document.getElementById('devShowLattice');
      const devShowWires = document.getElementById('devShowWires');
      const devShowPulses = document.getElementById('devShowPulses');
      const devShowFireflies = document.getElementById('devShowFireflies');
      const devShowEmbers = document.getElementById('devShowEmbers');
      const devShowLightning = document.getElementById('devShowLightning');
      const devShowBackdrop = document.getElementById('devShowBackdrop');
      const devCubeMapUrl = document.getElementById('devCubeMapUrl');
      const devOverlayUrl = document.getElementById('devOverlayUrl');
      const devOverlayOpacity = document.getElementById('devOverlayOpacity');
      const devSpeedMul = document.getElementById('devSpeedMul');
      const devTint = document.getElementById('devTint');
      const devApply = document.getElementById('devApply');
      const devReset = document.getElementById('devReset');
      let devOverlayImg = document.getElementById('devOverlayImg');

      const DevState = (window.__DEV_SPEED = window.__DEV_SPEED || {
        showScanner:true, showBlockGrid:true, showBlockScans:true, showLattice:true, showWires:true,
        showPulses:true, showFireflies:true, showEmbers:true, showLightning:true, showBackdrop:true,
        showMonoliths:true,
        showShards:true,
        cubeMapUrl:'', overlayUrl:'', overlayOpacity:0.5, speedMul:1, tint:'#c26200'
      });

      function toggleDevModal(v){ devModal.style.display = v ? 'block' : 'none'; }
      btnDev?.addEventListener('click', () => toggleDevModal(devModal.style.display === 'none' || devModal.style.display === ''));
      btnDevClose?.addEventListener('click', () => toggleDevModal(false));

      function applyDevToggles(){
        try { if (typeof scanner2 !== 'undefined' && scanner2) scanner2.visible = !!DevState.showScanner; } catch {}
        try { if (typeof mesh !== 'undefined' && mesh) mesh.visible = !!DevState.showBlockGrid; } catch {}
        try { if (typeof scanWrapPass !== 'undefined' && scanWrapPass && scanWrapPass.enabled !== undefined) scanWrapPass.enabled = !!DevState.showBlockScans; } catch {}
        try {
          if (typeof monolithGroup !== 'undefined' && monolithGroup) {
            const v = !!DevState.showMonoliths;
            monolithGroup.visible = v;
            // Force child meshes to honor visibility
            monolithGroup.traverse(n => { try { if (n && n.isMesh) n.visible = v; } catch {} });
          }
        } catch {}
        try { if (typeof shards !== 'undefined' && shards) shards.visible = !!DevState.showShards; } catch {}
        try { if (typeof gridGroup !== 'undefined' && gridGroup) gridGroup.visible = !!DevState.showLattice; } catch {}
        try { if (typeof thinGridGroup !== 'undefined' && thinGridGroup) thinGridGroup.visible = !!DevState.showLattice; } catch {}
        try { if (typeof latticeGroup !== 'undefined' && latticeGroup) latticeGroup.visible = !!DevState.showLattice; } catch {}
        try { if (typeof streamerGroup !== 'undefined' && streamerGroup) streamerGroup.visible = !!DevState.showWires; } catch {}
        try { if (typeof pulseGroup !== 'undefined' && pulseGroup) pulseGroup.visible = !!DevState.showPulses; } catch {}
        try { if (typeof fireflies !== 'undefined' && fireflies) fireflies.visible = !!DevState.showFireflies; } catch {}
        try { if (typeof embers !== 'undefined' && embers) embers.visible = !!DevState.showEmbers; } catch {}
        try { if (typeof lightningGroup !== 'undefined' && lightningGroup) lightningGroup.visible = !!DevState.showLightning; } catch {}
        try { if (typeof bgUniforms !== 'undefined' && bgUniforms && bgUniforms.uOpacity) bgUniforms.uOpacity.value = DevState.showBackdrop ? (bgUniforms.uOpacity.value||0.22) : 0.0; } catch {}
      }

      function ensureOverlayEl(){
        if (!devOverlayImg) {
          devOverlayImg = document.getElementById('devOverlayImg');
          if (!devOverlayImg) {
            try {
              const img = document.createElement('img');
              img.id = 'devOverlayImg'; img.alt = 'overlay';
              img.style.cssText = 'display:none;position:fixed;inset:0;pointer-events:none;z-index:8000;object-fit:cover;opacity:0.5;';
              document.body.appendChild(img);
              devOverlayImg = img;
            } catch {}
          }
        }
      }

      function tintMaterial(mat, col){
        try {
          if (!mat) return;
          if (mat.color) mat.color.copy(col);
          if (mat.emissive && mat.emissive.copy) {
            // small emissive push so tint is visible on highly metallic materials
            const e = col.clone().multiplyScalar(0.08);
            mat.emissive.copy(e);
          }
        } catch {}
      }
      function tintObjectRecursive(obj, col){
        try {
          if (!obj) return;
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(m => tintMaterial(m, col));
            else tintMaterial(obj.material, col);
          }
          if (obj.children && obj.children.length) obj.children.forEach(c => tintObjectRecursive(c, col));
        } catch {}
      }

      function ensureOrigOnMat(mat){
        try {
          if (!mat) return;
          if (!mat.userData) mat.userData = {};
          if (!mat.userData.__devOrig) {
            mat.userData.__devOrig = {
              color: mat.color ? mat.color.clone() : null,
              emissive: mat.emissive ? mat.emissive.clone() : null,
              map: mat.map || null
            };
          }
        } catch {}
      }
      function restoreOrigOnMat(mat){
        try {
          if (!mat || !mat.userData || !mat.userData.__devOrig) return;
          const o = mat.userData.__devOrig;
          if (o.color && mat.color) mat.color.copy(o.color);
          if (o.emissive && mat.emissive) mat.emissive.copy(o.emissive);
          if ('map' in mat) mat.map = o.map || null;
          mat.needsUpdate = true;
        } catch {}
      }
      function applyTextureToMaterial(mat, tex){
        try {
          if (!mat) return;
          ensureOrigOnMat(mat);
          // Only set on standard/physical-like materials with a color map slot
          if (mat.map !== undefined) {
            mat.map = tex;
            // set base color to white to let texture show true colors
            if (mat.color) mat.color.set(0xffffff);
            mat.needsUpdate = true;
          }
        } catch {}
      }
      function applyTextureRecursive(obj, tex){
        try {
          if (!obj) return;
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(m => applyTextureToMaterial(m, tex));
            else applyTextureToMaterial(obj.material, tex);
          }
          if (obj.children && obj.children.length) obj.children.forEach(c => applyTextureRecursive(c, tex));
        } catch {}
      }
      function restoreTextureRecursive(obj){
        try {
          if (!obj) return;
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(m => restoreOrigOnMat(m));
            else restoreOrigOnMat(obj.material);
          }
          if (obj.children && obj.children.length) obj.children.forEach(c => restoreTextureRecursive(c));
        } catch {}
      }

      function applyDevEffects(){
        try {
          if (DevState.cubeMapUrl && typeof THREE !== 'undefined') {
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = 'anonymous';
            loader.load(DevState.cubeMapUrl, (tex) => {
              try {
                // three r160 uses colorSpace; also set legacy encoding for safety
                if ('colorSpace' in tex) tex.colorSpace = THREE.SRGBColorSpace;
                if ('encoding' in tex) tex.encoding = THREE.sRGBEncoding;
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
              } catch {}
              // Apply to central instanced block grid mesh
              if (typeof mesh !== 'undefined' && mesh) applyTextureToMaterial(mesh.material, tex);
              // Apply to surrounding monolith blocks and any box-like children
              if (typeof monolithGroup !== 'undefined' && monolithGroup) applyTextureRecursive(monolithGroup, tex);
              if (typeof shards !== 'undefined' && shards && shards.material) applyTextureToMaterial(shards.material, tex);
              console.log('[Dev] Applied texture to blocks/monoliths/shards:', DevState.cubeMapUrl);
            }, undefined, (err) => {
              console.error('Dev texture load failed (URL/CORS/404):', DevState.cubeMapUrl, err);
            });
          } else {
            // Clear existing maps if URL removed
            if (typeof mesh !== 'undefined' && mesh && mesh.material) restoreOrigOnMat(mesh.material);
            if (typeof monolithGroup !== 'undefined' && monolithGroup) restoreTextureRecursive(monolithGroup);
            if (typeof shards !== 'undefined' && shards && shards.material) restoreOrigOnMat(shards.material);
          }
        } catch {}
        try {
          ensureOverlayEl();
          if (devOverlayImg) {
            if (DevState.overlayUrl) { devOverlayImg.src = DevState.overlayUrl; devOverlayImg.style.display = 'block'; devOverlayImg.style.opacity = String(DevState.overlayOpacity); }
            else { devOverlayImg.removeAttribute('src'); devOverlayImg.style.display = 'none'; }
          }
        } catch {}
        try {
          const col = new THREE.Color(DevState.tint || '#e7c39a');
          if (typeof strikeMat !== 'undefined' && strikeMat) strikeMat.color.copy(col);
          if (typeof emberMaterial !== 'undefined' && emberMaterial) emberMaterial.color?.copy?.(col);
          if (typeof fireflyMat !== 'undefined' && fireflyMat) fireflyMat.color?.copy?.(col);
          if (typeof mesh !== 'undefined' && mesh && mesh.material && mesh.material.color) mesh.material.color.copy(col);
          if (typeof shards !== 'undefined' && shards && shards.material && shards.material.color) tintMaterial(shards.material, col);
          if (typeof pulseMat !== 'undefined' && pulseMat && pulseMat.color) pulseMat.color.copy(col);
          // Tint groups and wires/grids best-effort
          if (typeof gridGroup !== 'undefined' && gridGroup) tintObjectRecursive(gridGroup, col);
          if (typeof thinGridGroup !== 'undefined' && thinGridGroup) tintObjectRecursive(thinGridGroup, col);
          if (typeof latticeGroup !== 'undefined' && latticeGroup) tintObjectRecursive(latticeGroup, col);
          if (typeof monolithGroup !== 'undefined' && monolithGroup) tintObjectRecursive(monolithGroup, col);
          if (typeof streamerGroup !== 'undefined' && streamerGroup) tintObjectRecursive(streamerGroup, col);
          if (typeof pulseGroup !== 'undefined' && pulseGroup) tintObjectRecursive(pulseGroup, col);
          // Scan uniforms
          try { if (scan2Uniforms) { scan2Uniforms.uMainColor?.value?.copy?.(col); scan2Uniforms.uSubColor?.value?.copy?.(col.clone().multiplyScalar(0.45)); } } catch {}
          try { if (scanWrapUniforms) { scanWrapUniforms.mainColor?.value?.copy?.(col); scanWrapUniforms.subColor?.value?.copy?.(col.clone().multiplyScalar(0.45)); } } catch {}
          try { if (scanHitUniforms && scanHitUniforms.uColor) { const c = scanHitUniforms.uColor.value || scanHitUniforms.uColor; if (c && c.copy) c.copy(col); } } catch {}
        } catch {}
      }

      // Patch THREE.Clock to scale time so main animate loop responds to speed multiplier
      function patchThreeClockSpeed(){
        try {
          if (!THREE || !THREE.Clock) return;
          if (!THREE.Clock.__devPatched) {
            const proto = THREE.Clock.prototype;
            const _getDelta = proto.getDelta;
            const _getElapsedTime = proto.getElapsedTime;
            proto.getDelta = function(){ const v = _getDelta.call(this); const s = (window.__DEV_SPEED?.speedMul || 1); return v * s; };
            proto.getElapsedTime = function(){ const v = _getElapsedTime.call(this); const s = (window.__DEV_SPEED?.speedMul || 1); return v * s; };
            THREE.Clock.__devPatched = true;
          }
        } catch {}
      }

      function bindDevInputs(){
        const bindChk = (el, key) => el?.addEventListener('change', () => { DevState[key] = el.checked; applyDevToggles(); });
        bindChk(devShowScanner, 'showScanner');
        bindChk(devShowBlockGrid, 'showBlockGrid');
        bindChk(devShowMonoliths, 'showMonoliths');
        bindChk(devShowBlockScans, 'showBlockScans');
        bindChk(devShowLattice, 'showLattice');
        bindChk(devShowWires, 'showWires');
        bindChk(devShowPulses, 'showPulses');
        bindChk(devShowFireflies, 'showFireflies');
        bindChk(devShowEmbers, 'showEmbers');
        bindChk(devShowLightning, 'showLightning');
        bindChk(devShowBackdrop, 'showBackdrop');
        bindChk(devShowMonoliths, 'showMonoliths');
        bindChk(devShowShards, 'showShards');
        devCubeMapUrl?.addEventListener('change', () => { DevState.cubeMapUrl = devCubeMapUrl.value.trim(); applyDevEffects(); });
        devOverlayUrl?.addEventListener('change', () => { DevState.overlayUrl = devOverlayUrl.value.trim(); applyDevEffects(); });
        devOverlayOpacity?.addEventListener('input', () => { DevState.overlayOpacity = parseFloat(devOverlayOpacity.value||'0.5'); applyDevEffects(); });
        devSpeedMul?.addEventListener('change', () => { DevState.speedMul = Math.max(0, parseFloat(devSpeedMul.value||'1')||1); patchThreeClockSpeed(); });
        devTint?.addEventListener('change', () => { DevState.tint = devTint.value; applyDevEffects(); });
        // Wrap Scan tuning controls (do not persist)
        try {
          const gw = document.getElementById('devGwMul');
          const gwb = document.getElementById('devGwBoost');
          const wob = document.getElementById('devWobbleMul');
          const wobb = document.getElementById('devWobbleBoost');
          const noi = document.getElementById('devNoiseMul');
          const noib = document.getElementById('devNoiseBoost');
          const onChange = () => {
            window.__DEV_WRAP = window.__DEV_WRAP || { gw:1, wob:1, noi:1, gwBoost:false, wobBoost:false, noiBoost:false };
            if (gw) window.__DEV_WRAP.gw = Math.max(0.2, parseFloat(gw.value||'1')||1);
            if (wob) window.__DEV_WRAP.wob = Math.max(0, parseFloat(wob.value||'1')||1);
            if (noi) window.__DEV_WRAP.noi = Math.max(0, parseFloat(noi.value||'1')||1);
            if (gwb) window.__DEV_WRAP.gwBoost = !!gwb.checked;
            if (wobb) window.__DEV_WRAP.wobBoost = !!wobb.checked;
            if (noib) window.__DEV_WRAP.noiBoost = !!noib.checked;
          };
          [gw, gwb, wob, wobb, noi, noib].forEach(el => el && el.addEventListener('input', onChange));
          onChange();
        } catch {}
        devApply?.addEventListener('click', () => { applyDevToggles(); applyDevEffects(); });
        devReset?.addEventListener('click', () => {
          Object.assign(DevState, { showScanner:true, showBlockGrid:true, showBlockScans:true, showLattice:true, showWires:true, showPulses:true, showFireflies:true, showEmbers:true, showLightning:true, showBackdrop:true, showMonoliths:true, cubeMapUrl:'', overlayUrl:'', overlayOpacity:0.5, speedMul:1, tint:'#c26200' });
          if (devCubeMapUrl) devCubeMapUrl.value = '';
          if (devOverlayUrl) devOverlayUrl.value = '';
          if (devOverlayOpacity) devOverlayOpacity.value = '0.5';
          if (devSpeedMul) devSpeedMul.value = '1';
          if (devTint) devTint.value = '#c26200';
          [devShowScanner,devShowBlockGrid,devShowMonoliths,devShowBlockScans,devShowLattice,devShowWires,devShowPulses,devShowFireflies,devShowEmbers,devShowLightning,devShowBackdrop].forEach(e => { if (e) e.checked = true; });
          applyDevToggles(); applyDevEffects();
        });
      }
      bindDevInputs();
      patchThreeClockSpeed();
      // Initial apply to sync with defaults
      applyDevToggles();
      applyDevEffects();
    })();

    // -----------------------
    // Keyboard shortcuts
    // -----------------------
    window.addEventListener('keydown', (e) => {
      const tag = (e.target && (e.target.tagName||'')).toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;
      if (e.code === 'Space') { e.preventDefault(); btnPlay.click(); }
      if (e.code === 'ArrowLeft') { btnPrev.click(); }
      if (e.code === 'ArrowRight') { btnNext.click(); }
      if (e.code === 'ArrowUp') { e.preventDefault(); const v = Math.min(1, (parseFloat(volume.value)||0)+0.05); volume.value = String(v); volume.oninput(new Event('input')); }
      if (e.code === 'ArrowDown') { e.preventDefault(); const v = Math.max(0, (parseFloat(volume.value)||0)-0.05); volume.value = String(v); volume.oninput(new Event('input')); }
      if (e.key.toLowerCase() === 'm') { modeSelect.value = (modeSelect.value === 'player') ? 'messages' : 'player'; modeSelect.onchange(new Event('change')); }
    });

    animate();

    // -----------------------
    // Audio capture and analyser
    // -----------------------
    let audioCtx = null, analyser = null, dataArray = null, sourceStream = null;
    const bands = { bass: 0, mid: 0, treble: 0 };
    async function startCapture() {
      try {
        // Stop previous stream if any
        try { if (sourceStream) sourceStream.getTracks?.().forEach(t => { try { t.stop(); } catch{} }); } catch {}
        sourceStream = null; analyser = null; dataArray = null;
        // Try tab/system audio first
        try {
          sourceStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        } catch (e1) {
          // Fallback to mic
          sourceStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        }
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state !== 'running') { try { await audioCtx.resume(); } catch {} }
        const source = audioCtx.createMediaStreamSource(sourceStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.85;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        setCaptureStatus('Audio: capturing');
      } catch (err) {
        console.warn('Audio capture failed', err);
        setCaptureStatus('Audio: denied');
      }
    }
    let playerCaptureStarted = false;
    async function ensurePlayerTabCapture() {
      if (playerCaptureStarted) return;
      try {
        // Ask for this-tab audio; many browsers require video:true for getDisplayMedia
        sourceStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state !== 'running') { try { await audioCtx.resume(); } catch {} }
        const source = audioCtx.createMediaStreamSource(sourceStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.85;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        playerCaptureStarted = true;
        setCaptureStatus('Audio: this tab');
      } catch (err) {
        console.warn('This-tab capture failed, visuals may not react to YT without capture.', err);
        setCaptureStatus('Audio: capture needed');
      }
    }
    function setCaptureStatus(t) { document.getElementById('captureStatus').textContent = t; }
    function releaseAudio(){
      try {
        if (sourceStream) {
          const tracks = sourceStream.getTracks?.() || [];
          tracks.forEach(tr => { try { tr.stop(); } catch{} });
        }
      } catch {}
      sourceStream = null;
      analyser = null; dataArray = null; playerCaptureStarted = false;
      try { if (audioCtx && audioCtx.state === 'running') audioCtx.suspend(); } catch {}
      // Reset strengths so visuals calm down
      try { audioStrength = { bass:0, mid:0, treble:0 }; } catch {}
      try { bands.bass = bands.mid = bands.treble = 0; } catch {}
      try { prevTreble = 0; prevTrebleRaw = 0; } catch {}
      try { if (typeof thunderEnergy !== 'undefined') thunderEnergy = 0; } catch {}
      try { if (typeof strobeEnergy !== 'undefined') strobeEnergy = 0; } catch {}
      // Restore defaults for some post effects if present
      try { if (film && film.uniforms && film.uniforms['nIntensity']) film.uniforms['nIntensity'].value = 0.25; } catch {}
      setCaptureStatus('Audio: idle');
    }

    function resetVisualizer(){
      // Non-destructive reset of visual state (no page/media/window disruption)
      try { audioStrength = { bass:0, mid:0, treble:0 }; } catch {}
      try { bands.bass = bands.mid = bands.treble = 0; } catch {}
      try { prevTreble = 0; prevTrebleRaw = 0; } catch {}
      try { if (typeof thunderEnergy !== 'undefined') thunderEnergy = 0; } catch {}
      try { if (typeof strobeEnergy !== 'undefined') strobeEnergy = 0; } catch {}
      // Reset shader pass parameters to safe defaults if available
      try { if (film && film.uniforms && film.uniforms['nIntensity']) film.uniforms['nIntensity'].value = 0.25; } catch {}
      try { if (scan2Uniforms) { scan2Uniforms.uGlow.value = 1.5; scan2Uniforms.uThickness.value = 0.08; scan2Uniforms.uSubThickness.value = 0.03; } } catch {}
      try {
        if (scanWrapUniforms) {
          scanWrapUniforms.glow.value = 1.4;
          scanWrapUniforms.thickness.value = 0.06;
          scanWrapUniforms.subThickness.value = 0.02;
          // New uniforms defaults
          scanWrapUniforms.gaussWidth.value = 1.35;
          scanWrapUniforms.noiseAmp.value = 0.04;
          scanWrapUniforms.noiseFreq.value = 0.9;
          scanWrapUniforms.wobbleAmp.value = 0.04;
          scanWrapUniforms.breathe.value = 0.0;
        }
      } catch {}
      try { if (scanHitUniforms) { scanHitUniforms.uGlow.value = 1.4; } } catch {}
    }

    function updateBands() {
      if (!analyser || !dataArray) return;
      analyser.getByteFrequencyData(dataArray);
      const n = dataArray.length;
      // Define frequency ranges roughly: bass < 200Hz, mid 200-2000Hz, treble > 2kHz
      const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
      const nyquist = sampleRate / 2;
      function binFor(freq) { return Math.min(n - 1, Math.max(0, Math.floor(freq / nyquist * n))); }
      const b0 = 0, b1 = binFor(200), m1 = binFor(2000);
      let sb = 0, sm = 0, st = 0, cb = 0, cm = 0, ct = 0;
      for (let i = b0; i < b1; i++) { sb += dataArray[i]; cb++; }
      for (let i = b1; i < m1; i++) { sm += dataArray[i]; cm++; }
      for (let i = m1; i < n; i++) { st += dataArray[i]; ct++; }
      bands.bass = cb ? sb / (cb * 255) : 0;
      bands.mid = cm ? sm / (cm * 255) : 0;
      bands.treble = ct ? st / (ct * 255) : 0;
    }

    // -----------------------
    // Player and playlists (YouTube IFrame API)
    // -----------------------
    const LS_KEY = 'bronze_visual_settings_v1';
    const state = { mode: 'player', playlist: [], shuffle: false, repeat: true, repeat1: false, volume: 0.8, messages: [], msgMode: 'paragraph', overlayEnabled: true, msgDraft: '', plantsEnabled: false };
    function getSavableState(){
      const toSave = JSON.parse(JSON.stringify(state));
      delete toSave.plantsEnabled; // always start plants OFF
      // Filter playlist: remove local and blob: items
      toSave.playlist = (toSave.playlist || []).filter(it => !(it?.local || (it?.type === 'audio' && (it?.url||'').startsWith('blob:'))));
      return toSave;
    }
    function saveState() {
      localStorage.setItem(LS_KEY, JSON.stringify(getSavableState()));
    }
    function loadState() {
      try { const s = JSON.parse(localStorage.getItem(LS_KEY) || '{}'); Object.assign(state, s); } catch {}
      // Defensive cleanup: strip any local/blob items that may have been saved previously
      state.playlist = (state.playlist || []).filter(it => !(it?.local || (it?.type === 'audio' && (it?.url||'').startsWith('blob:'))));
    }
    loadState();
    // Ensure saved playlist is rendered and loaded on app open
    try { if (typeof renderPlaylist === 'function') renderPlaylist(); } catch {}
    try {
      if ((state.playlist||[]).length > 0 && typeof loadIntoPlayer === 'function') {
        // Defer slightly to allow players to initialize
        setTimeout(() => { try { loadIntoPlayer(); } catch (e) { console.warn('Load on startup failed', e); } }, 250);
      }
    } catch {}

    const panel = document.getElementById('panel');
    const dock = document.querySelector('.dock-zone');
    let panelPinned = false;
    dock.addEventListener('touchstart', () => { panel.classList.add('show'); panelPinned = true; });
    dock.addEventListener('mouseenter', () => { if (!panelPinned) { panel.classList.add('show'); if (panelHideTimer) { clearTimeout(panelHideTimer); panelHideTimer = 0; } } });
    panel.addEventListener('mouseenter', () => { if (panelHideTimer) { clearTimeout(panelHideTimer); panelHideTimer = 0; } });
    panel.addEventListener('mouseleave', () => {
      if (!panelPinned) {
        if (panelHideTimer) clearTimeout(panelHideTimer);
        panelHideTimer = setTimeout(() => { panel.classList.remove('show'); }, 3000);
      }
    });

    // UI refs
    const modeSelect = document.getElementById('modeSelect');
    const btnCapture = document.getElementById('btnCapture');
    const btnPurge = document.getElementById('btnPurge');
    const btnExport = document.getElementById('btnExport');
    const importJson = document.getElementById('importJson');
    const btnSearchYT = document.getElementById('btnSearchYT');
    const btnShowVideo = document.getElementById('btnShowVideo');
    const btnReleaseAudio = document.getElementById('btnReleaseAudio');
    const btnResetVis = document.getElementById('btnResetVis');
    const ytSearchModal = document.getElementById('ytSearchModal');
    const btnCloseYtModal = document.getElementById('btnCloseYtModal');
    const btnRunYtSearch = document.getElementById('btnRunYtSearch');
    const ytQuery = document.getElementById('ytQuery');
    const ytResults = document.getElementById('ytResults');
    const overlayHtmlVideo = document.getElementById('overlayHtmlVideo');
    const ytPreview = document.getElementById('ytPreview');
    const ytApiKeyInput = document.getElementById('ytApiKey');
    const btnSaveApiKey = document.getElementById('btnSaveApiKey');
    const btnOpenApiKeyGuide = document.getElementById('btnOpenApiKeyGuide');
    const btnPrev = document.getElementById('btnPrev');
    const btnPlay = document.getElementById('btnPlay');
    const btnNext = document.getElementById('btnNext');
    const seek = document.getElementById('seek');
    const volume = document.getElementById('volume');
    const btnShuffle = document.getElementById('btnShuffle');
    const btnRepeat = document.getElementById('btnRepeat');
    const btnRepeat1 = document.getElementById('btnRepeat1');
    const addUrl = document.getElementById('addUrl');
    const btnAdd = document.getElementById('btnAdd');
    const playlistDiv = document.getElementById('playlist');
    const playerSection = document.getElementById('playerSection');
    const messagesSection = document.getElementById('messagesSection');
    const playlistSection = document.getElementById('playlistSection');
    const playlistMount = document.getElementById('playlistMount');
    const playlistHeaderEl = playlistSection.querySelector('.row .pill');
    const msgPreviewRow = document.getElementById('msgPreviewRow');
    const msgPreviewBox = document.getElementById('msgPreviewBox');
    // Live (Livestream) controls
    const liveControlsRow = document.getElementById('liveControlsRow');
    const sensBass = document.getElementById('sensBass');
    const sensMid = document.getElementById('sensMid');
    const sensTreble = document.getElementById('sensTreble');
    const sensPunchy = document.getElementById('sensPunchy');
    const sensThunder = document.getElementById('sensThunder');
    const sensThunderIntensity = document.getElementById('sensThunderIntensity');
    const msgMode = document.getElementById('msgMode');
    const btnEditMsg = document.getElementById('btnEditMsg');
    const btnClearMsg = document.getElementById('btnClearMsg');
    const msgInput = document.getElementById('msgInput');
    const btnNewLine = document.getElementById('btnNewLine');
    const msgSize = document.getElementById('msgSize');
    const msgSpeed = document.getElementById('msgSpeed');
    const msgLine = document.getElementById('msgLine');
    const msgPos = document.getElementById('msgPos');
    const msgAlign = document.getElementById('msgAlign');
    const messagesList = document.getElementById('messagesList');
    const messagesSectionHome = document.getElementById('messagesSection').parentElement; // original home for entire messages section
    const paragraphEl = document.getElementById('msgParagraph');
    const marquee = document.getElementById('marquee');
    const marqueeTrack = document.getElementById('marqueeTrack');
    const overlay = document.querySelector('.overlay');
    // Video window elements
    const videoWindow = document.getElementById('videoWindow');
    const videoWinBar = document.getElementById('videoWinBar');
    const btnCloseVideo = document.getElementById('btnCloseVideo');
    const btnMaximizeVideo = document.getElementById('btnMaximizeVideo');
    const videoOpacity = document.getElementById('videoOpacity');
    const videoOverlayPlayerHost = document.getElementById('videoOverlayPlayer');
    const videoNoContent = document.getElementById('videoNoContent');
    const btnRestoreVideo = document.getElementById('btnRestoreVideo');
    let lastLocalFileName = '';
    // Slide-up panel grace period handling
    const dockZone = document.querySelector('.dock-zone');
    const panelEl = document.getElementById('panel');
    let panelHideTimer = 0;
    function openPanel(){
      if (panelHideTimer) { clearTimeout(panelHideTimer); panelHideTimer = 0; }
      panelEl.classList.add('show');
    }
    function schedulePanelClose(){
      if (panelHideTimer) { clearTimeout(panelHideTimer); }
      panelHideTimer = setTimeout(() => { panelEl.classList.remove('show'); }, 2000);
    }
    dockZone.addEventListener('mouseenter', openPanel);
    panelEl.addEventListener('mouseenter', openPanel);
    dockZone.addEventListener('mouseleave', schedulePanelClose);
    panelEl.addEventListener('mouseleave', schedulePanelClose);
    // Message center options controls
    const optBackdrop = document.getElementById('optBackdrop');
    const optBand = document.getElementById('optBand');
    const optStroke = document.getElementById('optStroke');
    const optGlow = document.getElementById('optGlow');
    const optBorder = document.getElementById('optBorder');
    const optBackdropOpacity = document.getElementById('optBackdropOpacity');
    const optBackdropBlur = document.getElementById('optBackdropBlur');
    const optBorderWidth = document.getElementById('optBorderWidth');
    const optBorderColor = document.getElementById('optBorderColor');

    // Mode init
    // Defaults for sensitivity if absent
    if (state.sensBass == null) state.sensBass = 1;
    if (state.sensMid == null) state.sensMid = 1;
    if (state.sensTreble == null) state.sensTreble = 1;
    if (state.sensPunchy == null) state.sensPunchy = false;
    if (state.sensThunder == null) state.sensThunder = false;
    if (state.sensThunderIntensity == null) state.sensThunderIntensity = 1.0;
    // Defaults for message options
    if (!state.msgOptions) state.msgOptions = { backdrop: true, band: true, stroke: true, glow: true, border: false, backdropOpacity: 0.9, backdropBlur: 8, borderWidth: 2, borderColor: '#ba7848', lineHeight: 1.2 };
    // Defaults for message settings
    if (!state.msgPos) state.msgPos = 'bottom';
    if (!state.msgAlign) state.msgAlign = 'left';
    // Force Music Player as default mode on page load
    state.mode = 'player';
    // (Removed) Proxy settings: not used
    modeSelect.value = 'player';
    msgMode.value = state.msgMode;
    if (msgAlign) msgAlign.value = state.msgAlign;
    // Plants toggle init
    const togglePlants = document.getElementById('togglePlants');
    const toggleOverlay = document.getElementById('toggleOverlay');
    if (togglePlants) {
      // Always default OFF on page load and do not persist this setting
      state.plantsEnabled = false;
      togglePlants.checked = false;
      togglePlants.onchange = () => { state.plantsEnabled = togglePlants.checked; setPlantsEnabled(state.plantsEnabled); };
    }
    if (toggleOverlay) {
      if (state.overlayEnabled == null) state.overlayEnabled = true;
      toggleOverlay.checked = !!state.overlayEnabled;
      toggleOverlay.onchange = () => { state.overlayEnabled = toggleOverlay.checked; saveState(); updateOverlay(); };
    }
    sensBass.value = String(state.sensBass);
    sensMid.value = String(state.sensMid);
    sensTreble.value = String(state.sensTreble);
    sensPunchy.checked = !!state.sensPunchy;
    sensThunder.checked = !!state.sensThunder;
    sensThunderIntensity.value = String(state.sensThunderIntensity);
    // (Removed) Proxy UI sync
    // Init message options UI
    optBackdrop.checked = !!state.msgOptions.backdrop;
    optBand.checked = !!state.msgOptions.band;
    optStroke.checked = !!state.msgOptions.stroke;
    optGlow.checked = !!state.msgOptions.glow;
    optBorder.checked = !!state.msgOptions.border;
    optBackdropOpacity.value = String(state.msgOptions.backdropOpacity ?? 0.9);
    optBackdropBlur.value = String(state.msgOptions.backdropBlur ?? 8);
    optBorderWidth.value = String(state.msgOptions.borderWidth ?? 2);
    optBorderColor.value = String(state.msgOptions.borderColor ?? '#ba7848');
    // (Removed) Proxy UI wiring
    msgLine.value = String(state.msgOptions.lineHeight ?? 1.2);
    msgPos.value = String(state.msgPos || 'bottom');

    // Hide sections pre-layout to avoid initial flash
    if (msgPreviewRow) msgPreviewRow.style.display = 'none';
    if (playlistSection) playlistSection.style.display = 'none';
    if (messagesSection) messagesSection.style.display = 'none';

    // --- Message Center: live preview ---
    let previewTimer = 0; let previewPhase = 0; // for marquee simulation
    function updatePreview(){
      if (!msgPreviewBox) return;
      if (state.mode !== 'messages') return; // do not render preview outside Message Center
      // Use only current editor text; no fallback to saved messages
      const txt = (msgInput.value || state.msgDraft || '').trim();
      const mode = msgMode.value;
      const size = parseInt(msgSize.value || '38', 10);
      const lineH = parseFloat(msgLine.value || '1.2');
      const speed = parseFloat(msgSpeed.value || '60');
      msgPreviewBox.innerHTML = '';
      msgPreviewBox.style.overflow = 'hidden';
      if (previewTimer) { cancelAnimationFrame(previewTimer); previewTimer = 0; }
      if (!txt) { msgPreviewBox.textContent = 'Type a message to preview…'; return; }
      if (mode === 'paragraph') {
        const s = document.createElement('div');
        s.textContent = txt;
        s.style.whiteSpace = 'pre-line';
        s.style.fontSize = size + 'px';
        s.style.lineHeight = String(lineH);
        s.style.fontFamily = "Impact, Haettenschweiler, 'Arial Black', 'Segoe UI Black', sans-serif";
        s.style.textTransform = 'uppercase';
        s.style.webkitTextStroke = '1px rgba(0,0,0,0.65)';
        s.style.textShadow = '0 2px 2px rgba(0,0,0,0.75), 0 0 12px rgba(240,170,100,0.45), 0 0 24px rgba(240,170,100,0.25)';
        s.style.color = '#f1cda2';
        // Allow preview to scroll when the paragraph is tall
        s.style.maxHeight = '160px';
        s.style.overflowY = 'auto';
        s.classList.add('scrollbox');
        const align = state.msgAlign || 'left';
        s.style.textAlign = align;
        msgPreviewBox.appendChild(s);
      } else if (mode === 'marqueeH') {
        const track = document.createElement('div');
        track.style.whiteSpace = 'nowrap';
        msgPreviewBox.appendChild(track);
        const lines = txt.split(/\n+/).filter(s => s.length);
        const gapPx = Math.max(0, (lineH - 1.0) * size) + 24;
        lines.forEach((line) => {
          const sp = document.createElement('span');
          sp.textContent = line;
          sp.style.marginRight = gapPx + 'px';
          sp.style.fontSize = size + 'px';
          sp.style.fontFamily = "Impact, Haettenschweiler, 'Arial Black', 'Segoe UI Black', sans-serif";
          sp.style.textTransform = 'uppercase';
          sp.style.webkitTextStroke = '1px rgba(0,0,0,0.65)';
          sp.style.textShadow = '0 2px 2px rgba(0,0,0,0.75), 0 0 10px rgba(240,170,100,0.35), 0 0 22px rgba(240,170,100,0.22)';
          sp.style.color = '#f1cda2';
          sp.style.textAlign = state.msgAlign || 'left';
          track.appendChild(sp);
        });
        const start = performance.now();
        const laneW = msgPreviewBox.getBoundingClientRect().width;
        function tickH(ts){
          const t = (ts - start) / 1000;
          const w = track.getBoundingClientRect().width;
          const period = laneW + w + 24;
          const x = laneW - ((t * speed) % period);
          track.style.transform = `translateX(${x}px)`;
          previewTimer = requestAnimationFrame(tickH);
        }
        previewTimer = requestAnimationFrame(tickH);
      } else if (mode === 'marqueeV') {
        const track = document.createElement('div');
        track.style.whiteSpace = 'normal';
        track.style.display = 'block';
        msgPreviewBox.appendChild(track);
        const lines = txt.split(/\n+/).filter(s => s.length);
        const gapPy = Math.max(0, (lineH - 1.0) * size) + 12;
        lines.forEach((line) => {
          const sp = document.createElement('span');
          sp.textContent = line;
          sp.style.display = 'block';
          sp.style.textAlign = state.msgAlign || 'left';
          sp.style.marginBottom = gapPy + 'px';
          sp.style.fontSize = size + 'px';
          sp.style.fontFamily = "Impact, Haettenschweiler, 'Arial Black', 'Segoe UI Black', sans-serif";
          sp.style.textTransform = 'uppercase';
          sp.style.webkitTextStroke = '1px rgba(0,0,0,0.65)';
          sp.style.textShadow = '0 2px 2px rgba(0,0,0,0.75), 0 0 10px rgba(240,170,100,0.35), 0 0 22px rgba(240,170,100,0.22)';
          sp.style.color = '#f1cda2';
          track.appendChild(sp);
        });
        const start = performance.now();
        function tickV(ts){
          const t = (ts - start) / 1000;
          const ch = msgPreviewBox.getBoundingClientRect().height;
          const h = track.getBoundingClientRect().height;
          const periodY = ch + h + 12;
          const y = ch - ((t * speed) % periodY);
          track.style.transform = `translateY(${y}px)`;
          previewTimer = requestAnimationFrame(tickV);
        }
        previewTimer = requestAnimationFrame(tickV);
      }
    }

    function applyMarqueePosition(){
      const pos = msgPos.value || 'bottom';
      marquee.style.top = '';
      marquee.style.bottom = '';
      marquee.style.transform = '';
      if (pos === 'bottom') { marquee.style.bottom = '6vh'; }
      else if (pos === 'top') { marquee.style.top = '6vh'; }
      else { // center
        marquee.style.top = '50%';
        marquee.style.transform = 'translateY(-50%)';
      }
    }

    function updateMessageControlsVisibility(){
      const isMarquee = (msgMode.value === 'marqueeH' || msgMode.value === 'marqueeV');
      // Toggle msgSpeed and msgPos visibility
      const posLabel = msgPos.closest('label');
      if (posLabel) posLabel.style.display = isMarquee ? '' : 'none';
      msgSpeed.style.display = isMarquee ? '' : 'none';
    }

    function applyMsgOptions(){
      overlay.classList.toggle('backdrop-off', !state.msgOptions.backdrop);
      overlay.classList.toggle('band-off', !state.msgOptions.band);
      overlay.classList.toggle('stroke-off', !state.msgOptions.stroke);
      overlay.classList.toggle('glow-off', !state.msgOptions.glow);
      overlay.classList.toggle('backdrop-border', !!state.msgOptions.border);
      overlay.style.setProperty('--msgBackdropOpacity', String(state.msgOptions.backdropOpacity ?? 0.9));
      overlay.style.setProperty('--msgBackdropBlur', (state.msgOptions.backdropBlur ?? 8) + 'px');
      overlay.style.setProperty('--msgBackdropBorderWidth', (state.msgOptions.border ? (state.msgOptions.borderWidth ?? 2) : 0) + 'px');
      overlay.style.setProperty('--msgBackdropBorderColor', String(state.msgOptions.borderColor ?? '#ba7848'));
      paragraphEl.style.lineHeight = String(state.msgOptions.lineHeight ?? 1.2);

      // Dynamic frosting: if opacity is near full, enforce heavy frosting so shapes are not discernible
      const op = state.msgOptions.backdropOpacity ?? 0.9;
      const blurPx = state.msgOptions.backdropBlur ?? 8;
      if (op >= 0.95) {
        const frostPx = Math.max(20, Math.round(blurPx * 2.2));
        overlay.style.setProperty('--msgFrostPx', frostPx + 'px');
        overlay.style.setProperty('--msgFrostBright', '0.45');
        overlay.style.setProperty('--msgFrostSat', '0.25');
      } else {
        // Moderate frosting tied to blur
        overlay.style.setProperty('--msgFrostPx', Math.max(8, Math.round(blurPx * 1.2)) + 'px');
        overlay.style.setProperty('--msgFrostBright', '0.72');
        overlay.style.setProperty('--msgFrostSat', '0.65');
      }
    }
    // Wire message options events
    optBackdrop.onchange = () => { state.msgOptions.backdrop = optBackdrop.checked; saveState(); applyMsgOptions(); };
    optBand.onchange = () => { state.msgOptions.band = optBand.checked; saveState(); applyMsgOptions(); };
    optStroke.onchange = () => { state.msgOptions.stroke = optStroke.checked; saveState(); applyMsgOptions(); };
    optGlow.onchange = () => { state.msgOptions.glow = optGlow.checked; saveState(); applyMsgOptions(); };
    optBorder.onchange = () => { state.msgOptions.border = optBorder.checked; saveState(); applyMsgOptions(); };
    optBackdropOpacity.oninput = () => { state.msgOptions.backdropOpacity = parseFloat(optBackdropOpacity.value); saveState(); applyMsgOptions(); };
    optBackdropBlur.oninput = () => { state.msgOptions.backdropBlur = parseFloat(optBackdropBlur.value); saveState(); applyMsgOptions(); };
    optBorderWidth.oninput = () => { state.msgOptions.borderWidth = parseInt(optBorderWidth.value||'0',10); saveState(); applyMsgOptions(); };
    optBorderColor.oninput = () => { state.msgOptions.borderColor = optBorderColor.value; saveState(); applyMsgOptions(); };
    msgLine.oninput = () => { state.msgOptions.lineHeight = parseFloat(msgLine.value); saveState(); applyMsgOptions(); };

    // Playlist rendering
    function renderPlaylist() {
      playlistDiv.innerHTML = '';
      updatePlaylistCounts();
      state.playlist.forEach((item, idx) => {
        const row = document.createElement('div'); row.className = 'row';
        const drag = document.createElement('span'); drag.textContent = '≡'; drag.className = 'handle pill';
        const name = document.createElement('span'); name.textContent = item.title || item.name || (item.type==='video'||item.type==='playlist'?`${item.type}:${item.id}`: (item.url||'item')); name.className = 'grow link';
        if (item.local) {
          const badge = document.createElement('span'); badge.className = 'badge session'; badge.textContent = 'session-only'; name.appendChild(badge);
        }
        name.title = 'Play this item now';
        name.onclick = () => { if (state.shuffle) resetPlayHistory(true); playItemAt(idx); };
        const del = document.createElement('button'); del.textContent = '✖'; del.onclick = () => { state.playlist.splice(idx,1); saveState(); renderPlaylist(); };
        row.appendChild(drag); row.appendChild(name); row.appendChild(del);
        // Drag and drop
        row.draggable = true; row.dataset.index = String(idx);
        row.addEventListener('dragstart', (e) => { e.dataTransfer?.setData('text/plain', String(idx)); });
        row.addEventListener('dragover', (e) => { e.preventDefault(); });
        row.addEventListener('drop', (e) => {
          e.preventDefault();
          const from = parseInt(e.dataTransfer?.getData('text/plain')||'-1',10);
          const to = idx;
          if (from>=0 && to>=0 && from!==to){
            const it = state.playlist.splice(from,1)[0];
            state.playlist.splice(to,0,it);
            saveState();
            renderPlaylist();
    applyModeLayout();
    applyMsgOptions();
    updatePlayerButtonsUI();
            if (ytPlayer) loadIntoPlayer();
          }
        });
        playlistDiv.appendChild(row);
      });
    }
    // Ensure legacy entries get parsed on load
    state.playlist = state.playlist.map(it => {
      if (it && it.type) return it;
      const p = classifyUrl(it.url || it.id || '');
      return p ? p : it;
    });
    saveState();
    renderPlaylist();

    // Messages rendering
    function renderMessages() {
      messagesList.innerHTML = '';
      state.messages.forEach((m, i) => {
        const row = document.createElement('div'); row.className = 'row';
        const t = document.createElement('span'); t.textContent = m.text; t.className = 'grow';
        const del = document.createElement('button'); del.textContent = '✖'; del.onclick = () => { state.messages.splice(i,1); saveState(); renderMessages(); };
        row.appendChild(t); row.appendChild(del); messagesList.appendChild(row);
      });
    }
    renderMessages();

    // ---------- Initial UI sync ----------
    // restore current draft into the editor
    if (typeof state.msgDraft === 'string') { msgInput.value = state.msgDraft; }
    updateMessageControlsVisibility();
    applyMarqueePosition();
    applyModeLayout();
    // Apply message styling options (restores border, glow, stroke, etc.)
    applyMsgOptions();
    updatePreview();
    updateOverlay();

    // Message overlay updates
    function updateOverlay() {
      // Global enable switch
      if (!state.overlayEnabled) { paragraphEl.style.opacity = 0; marquee.style.opacity = 0; return; }
      const mode = msgMode.value;
      // Use only current editor text; no fallback to saved messages
      const txt = (msgInput.value || state.msgDraft || '').trim();
      const size = parseInt(msgSize.value || '38', 10);
      const speed = parseInt(msgSpeed.value || '60', 10);
      const align = state.msgAlign || 'left';
      if (!txt) {
        // Fully hide and clear DOM state
        paragraphEl.style.opacity = 0;
        marquee.style.opacity = 0;
        paragraphEl.textContent = '';
        marqueeTrack.innerHTML = '';
        marqueeTrack.style.transform = '';
        marquee.style.height = '';
        paragraphEl.style.display = 'none';
        marquee.style.display = 'none';
        return;
      }
      // Ensure visible when we have text
      paragraphEl.style.display = '';
      marquee.style.display = '';
      if (mode === 'paragraph') {
        paragraphEl.textContent = txt; paragraphEl.style.opacity = 0.9; marquee.style.opacity = 0;
        paragraphEl.style.fontSize = size + 'px';
        paragraphEl.style.lineHeight = String(state.msgOptions.lineHeight ?? 1.2);
        paragraphEl.style.textAlign = align;
      } else {
        paragraphEl.style.opacity = 0; marquee.style.opacity = 0.9;
        marqueeTrack.innerHTML = '';
        marqueeTrack.style.fontSize = size + 'px';
        const lines = txt.split(/\n+/).filter(s => s.length);
        const lineGapPx = Math.max(0, (parseFloat(state.msgOptions.lineHeight ?? 1.2) - 1.0) * size);
        const t = performance.now() / 1000;

        if (mode === 'marqueeH') {
          // Horizontal: start fully off-screen to the right, move left, exit left fully, then repeat
          marqueeTrack.style.whiteSpace = 'nowrap';
          marqueeTrack.style.display = 'inline-block';
          marquee.style.height = (size * 1.6) + 'px';
          // Build spans per line with horizontal gaps controlled by line spacing
          lines.forEach((line, i) => {
            const s = document.createElement('span');
            s.textContent = line;
            s.style.marginRight = (lineGapPx + 24) + 'px'; // base gap 24px plus line spacing
            s.style.textAlign = align;
            marqueeTrack.appendChild(s);
          });
          const cw = marquee.getBoundingClientRect().width; // container width
          const w = marqueeTrack.getBoundingClientRect().width; // content width including gaps
          const baseGap = 24; // breathing gap
          const period = cw + w + baseGap;
          const x = cw - ((t * speed) % period);
          marqueeTrack.style.transform = `translateX(${x}px)`;
        } else if (mode === 'marqueeV') {
          // Vertical: start fully below (off-screen), move up, exit above, then repeat
          marqueeTrack.style.whiteSpace = 'normal';
          marqueeTrack.style.display = 'block';
          // Build one span per line stacked vertically with spacing; use span so CSS effects apply
          lines.forEach((line) => {
            const s = document.createElement('span');
            s.textContent = line;
            s.style.display = 'block';
            s.style.textAlign = align;
            s.style.marginBottom = (lineGapPx + 12) + 'px';
            marqueeTrack.appendChild(s);
          });
          // Give vertical marquee a taller lane
          const laneH = Math.max(size * 2.2, 64);
          marquee.style.height = laneH + 'px';
          const ch = marquee.getBoundingClientRect().height; // container height
          const h = marqueeTrack.getBoundingClientRect().height; // content height including gaps
          const gapY = 12;
          const periodY = ch + h + gapY;
          const y = ch - ((t * speed) % periodY);
          marqueeTrack.style.transform = `translateY(${y}px)`;
        }
      }
    }

    // -----------------------
    // YouTube player (audio-only hidden)
    // -----------------------
    let ytPlayer = null; let seekTimer = null; let currentPlaylist = []; let currentIndex = 0;
    const playerContainer = document.createElement('div');
    playerContainer.id = 'yt-player';
    playerContainer.style.position = 'fixed';
    playerContainer.style.width = '1px';
    playerContainer.style.height = '1px';
    playerContainer.style.left = '-10px';
    playerContainer.style.top = '-10px';
    playerContainer.style.opacity = '0';
    document.body.appendChild(playerContainer);

    // URL parsing helpers
    function isAudioUrl(url){ return /\.(mp3|aac|m4a|ogg|opus|wav)$/i.test(url) || /\.m3u8$/i.test(url); }
    function parseYouTubeUrl(url) {
      try {
        const u = new URL(url);
        if (u.hostname.includes('youtube.com') || u.hostname.includes('youtu.be')) {
          const list = u.searchParams.get('list');
          if (list) return { type: 'playlist', id: list };
          // video id
          if (u.hostname.includes('youtu.be')) {
            const id = u.pathname.slice(1);
            return id ? { type: 'video', id } : null;
          }
          const id = u.searchParams.get('v');
          if (id) return { type: 'video', id };
        }
      } catch {}
      // Allow bare IDs
      if (/^[A-Za-z0-9_-]{8,}$/.test(url)) return { type: 'video', id: url };
      return null;
    }

    function classifyUrl(url){
      if (isAudioUrl(url)) return { type:'audio', url };
      const yt = parseYouTubeUrl(url); if (yt) return yt; return { type:'unknown', url };
    }

    function buildPlaylistArray() {
      // Build a flat list of video IDs if user added playlist IDs by fetching is out-of-scope (no API key)
      // For playlist IDs we will use player.loadPlaylist by list ID instead of array.
      const videos = state.playlist.filter(it => it.type === 'video').map(it => it.id);
      return videos;
    }

    // Expose IFrame API ready
    window.onYouTubeIframeAPIReady = () => {
      ytPlayer = new YT.Player('yt-player', {
        width: '1', height: '1', videoId: '',
        playerVars: { autoplay: 0, controls: 0, disablekb: 1, modestbranding: 1, rel: 0, playsinline: 1 },
        events: {
          onReady: () => {
            volume.value = String(state.volume);
            try { ytPlayer.setVolume(Math.round(state.volume * 100)); } catch {}
            if (state.playlist.length) loadIntoPlayer();
            startSeekSync();
          },
          onStateChange: (e) => {
            const P = YT.PlayerState;
            if (e.data === P.PLAYING) btnPlay.textContent = '⏸';
            else if (e.data === P.PAUSED || e.data === P.ENDED) btnPlay.textContent = '⏵';
            if (e.data === P.ENDED) {
              // Repeat-1 overrides others: loop current video
              if (state.repeat1) { try { ytPlayer.seekTo(0, true); ytPlayer.playVideo(); } catch {} return; }
              // Otherwise advance to next playlist item (works across types)
              nextItem();
            }
          }
        }
      });
    };

    function hasPlaylistId() {
      return state.playlist.some(it => it.type === 'playlist');
    }

    function loadIntoPlayer() {
      const plId = state.playlist.find(it => it.type === 'playlist')?.id;
      if (plId) {
        ytPlayer.loadPlaylist({ listType: 'playlist', list: plId, index: 0 });
        return;
      }
      currentPlaylist = buildPlaylistArray();
      if (!currentPlaylist.length) return;
      if (state.shuffle) shuffleArray(currentPlaylist);
      currentIndex = 0;
      ytPlayer.loadPlaylist(currentPlaylist);
      ytPlayer.setLoop(state.repeat);
    }

    // Playback engine: HTMLAudio for 'audio' items; YT for youtube items (non-reactive in player mode)
    const audioEl = new Audio(); audioEl.crossOrigin = 'anonymous'; audioEl.preload = 'auto'; audioEl.loop = false; audioEl.volume = state.volume;
    let audioNode = null; let usingHls = null;
    function ensureAudioAnalyser() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (!audioNode) {
        audioNode = audioCtx.createMediaElementSource(audioEl);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.85;
        audioNode.connect(analyser); analyser.connect(audioCtx.destination);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
      }
    }
    function loadAudio(url){
      if (usingHls) { try { usingHls.destroy(); } catch {} usingHls = null; }
      if (/\.m3u8$/i.test(url)) {
        if (window.Hls && Hls.isSupported()) {
          usingHls = new Hls(); usingHls.loadSource(url); usingHls.attachMedia(audioEl);
        } else {
          audioEl.src = url; // some browsers support native HLS
        }
      } else {
        audioEl.src = url;
      }
    }
    function stopHtmlAudio() {
      try { audioEl.pause(); } catch {}
      try { if (usingHls) { usingHls.destroy(); usingHls = null; } } catch {}
      try { audioEl.src = ''; } catch {}
    }
    function stopOverlayVideoFile(){
      try { overlayHtmlVideo.pause(); } catch {}
      try { overlayHtmlVideo.removeAttribute('src'); overlayHtmlVideo.load?.(); } catch {}
      try { overlayHtmlVideo.style.display = 'none'; } catch {}
    }
    function stopYouTube() {
      try { ytPlayer && ytPlayer.stopVideo && ytPlayer.stopVideo(); } catch {}
    }
    function playItemAt(idx){
      currentIndex = idx;
      const item = state.playlist[idx]; if (!item) return;
      markPlayed(idx);
      // Hard stop both engines first to avoid overlap
      stopHtmlAudio();
      stopYouTube();
      stopOverlayVideoFile?.();
      if (item.type === 'audio') {
        ensureAudioAnalyser();
        loadAudio(item.url);
        audioEl.play(); btnPlay.textContent = '⏸';
        // Repeat-1: if enabled, loop current audio item when it ends; otherwise preserve existing behavior
        audioEl.onended = () => {
          if (state.repeat1) { try { audioEl.currentTime = 0; audioEl.play(); } catch {} }
          else { nextItem(); }
        };
      } else if (item.type === 'playlist') {
        ytPlayer && ytPlayer.loadPlaylist({ listType:'playlist', list:item.id, index:0 }); btnPlay.textContent = '⏸';
      } else if (item.type === 'video') {
        ytPlayer && ytPlayer.loadVideoById(item.id); btnPlay.textContent = '⏸';
      } else if (item.type === 'videoFile') {
        // Local file video: show in overlayHtmlVideo inside the video window
        showVideoWindow();
        videoNoContent.style.display = 'none';
        try { videoOverlayPlayerHost.style.display = 'none'; } catch {}
        overlayHtmlVideo.style.display = '';
        overlayHtmlVideo.src = item.url;
        overlayHtmlVideo.currentTime = 0;
        overlayHtmlVideo.play(); btnPlay.textContent = '⏸';
        overlayHtmlVideo.onended = () => {
          if (state.repeat1) { try { overlayHtmlVideo.currentTime = 0; overlayHtmlVideo.play(); } catch {} }
          else { nextItem(); }
        };
      }
    }
    function nextItem(){
      const n = state.playlist.length; if (!n) return;
      const ni = computeNextIndex();
      if (ni === -1) {
        // Stop playback cleanly
        try { audioEl.pause(); } catch{}
        try { ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); } catch{}
        try { overlayHtmlVideo.pause(); } catch{}
        btnPlay.textContent = '⏵';
        return;
      }
      if (ni === currentIndex && state.repeat1) {
        // Loop current handled by specific handlers (audio/video/YT); nothing to do
        return;
      }
      playItemAt(ni);
    }
    function prevItem(){ const n = state.playlist.length; if (!n) return; playItemAt((currentIndex-1+n)%n); }
    function togglePlay(){
      const item = state.playlist[currentIndex]; if (!item) return;
      if (item.type === 'audio') {
        ensureAudioAnalyser();
        if (audioEl.paused) audioEl.play(); else audioEl.pause();
        btnPlay.textContent = audioEl.paused ? '⏵' : '⏸';
      } else {
        const st = ytPlayer.getPlayerState(); const P = YT.PlayerState; if (st === P.PLAYING) ytPlayer.pauseVideo(); else ytPlayer.playVideo();
      }
    }

    function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    // Track which indices have been played in current session (for Shuffle without Repeat)
    let playedSet = new Set();
    function resetPlayHistory(includeCurrent = true){
      playedSet = new Set();
      if (includeCurrent && currentIndex >= 0) playedSet.add(currentIndex);
    }
    function markPlayed(idx){ try { playedSet.add(idx); } catch{} }
    function computeNextIndex(){
      const n = state.playlist.length; if (!n) return -1;
      // If repeating single item, stay on current
      if (state.repeat1) return currentIndex;
      if (state.shuffle) {
        // Pick any unplayed index; if none, either stop or reset depending on Repeat
        const remaining = [];
        for (let i = 0; i < n; i++) { if (i !== currentIndex && !playedSet.has(i)) remaining.push(i); }
        if (remaining.length > 0) {
          const pick = remaining[Math.floor(Math.random()*remaining.length)];
          return pick;
        }
        // All played
        if (state.repeat) {
          playedSet = new Set(); // reset history and pick a new random different from current if possible
          const choices = Array.from({length:n}, (_,i)=>i).filter(i=>i!==currentIndex);
          return choices.length ? choices[Math.floor(Math.random()*choices.length)] : currentIndex;
        }
        return -1; // stop
      } else {
        // Linear progression
        if (currentIndex < n - 1) return currentIndex + 1;
        return state.repeat ? 0 : -1;
      }
    }

    function startSeekSync(){
      if (seekTimer) return; // already
      seekTimer = setInterval(() => {
        const item = state.playlist[currentIndex];
        if (item && item.type === 'audio') {
          const d = audioEl.duration||0, t = audioEl.currentTime||0; if (d>0 && !draggingSeek) seek.value = String(Math.round((t/d)*100));
        } else if (item && item.type === 'videoFile') {
          const d = overlayHtmlVideo.duration||0, t = overlayHtmlVideo.currentTime||0; if (d>0 && !draggingSeek) seek.value = String(Math.round((t/d)*100));
        } else if (ytPlayer && typeof ytPlayer.getDuration === 'function') {
          const d = ytPlayer.getDuration() || 0; const t = ytPlayer.getCurrentTime() || 0; if (d>0 && !draggingSeek) seek.value = String(Math.round((t/d)*100));
        }
      }, 333);
    }

    let draggingSeek = false;

    // -----------------------
    // Video overlay window logic
    // -----------------------
    let overlayPlayer = null; let overlaySyncTimer = 0; let chromeTimer = 0; let draggingVideo = false;
    let isMaximized = false; let savedRect = null;
    function ensureOverlayPlayer(){
      if (overlayPlayer || !(window.YT && YT.Player)) return;
      overlayPlayer = new YT.Player('videoOverlayPlayer', {
        width: '100%', height: '100%', videoId: '',
        playerVars: { autoplay: 0, controls: 0, disablekb: 1, modestbranding: 1, rel: 0, playsinline: 1 },
        events: {
          onReady: () => { try { overlayPlayer.mute(); } catch {} },
        }
      });
    }
    function showVideoWindow(){
      videoWindow.style.display = '';
      videoWindow.classList.remove('chrome-hidden');
      ensureOverlayPlayer();
      scheduleChromeHide();
      startOverlaySync();
      syncOverlayNow();
      try { document.body.classList.add('cursor-on'); document.documentElement.classList.add('cursor-on'); } catch {}
    }
    function hideVideoWindow(){
      videoWindow.style.display = 'none';
      stopOverlaySync();
      try { overlayPlayer && overlayPlayer.stopVideo && overlayPlayer.stopVideo(); } catch {}
      try { document.body.classList.remove('cursor-on'); document.documentElement.classList.remove('cursor-on'); } catch {}
      isMaximized = false; savedRect = null; btnRestoreVideo.style.display = 'none';
      videoWindow.classList.remove('maximized');
    }
    function scheduleChromeHide(){
      if (chromeTimer) clearTimeout(chromeTimer);
      chromeTimer = setTimeout(() => { videoWindow.classList.add('chrome-hidden'); }, 3000);
    }
    function showChrome(){
      if (chromeTimer) clearTimeout(chromeTimer);
      videoWindow.classList.remove('chrome-hidden');
      scheduleChromeHide();
    }
    videoWindow.addEventListener('mouseenter', showChrome);
    videoWindow.addEventListener('mousemove', showChrome);
    videoWindow.addEventListener('mouseleave', () => {
      if (chromeTimer) clearTimeout(chromeTimer);
      videoWindow.classList.add('chrome-hidden');
    });
    // Proximity-based restore button (top-center proximity)
    videoWindow.addEventListener('mousemove', (e) => {
      if (!isMaximized) { btnRestoreVideo.style.display = 'none'; return; }
      const r = videoWindow.getBoundingClientRect();
      const cx = r.left + r.width/2; const cy = r.top; // top center
      const dx = Math.abs(e.clientX - cx); const dy = Math.abs(e.clientY - cy);
      // Larger proximity zone for easier discovery
      if (dx < 200 && dy < 90) btnRestoreVideo.style.display = '';
      else btnRestoreVideo.style.display = 'none';
    });
    // Dragging by top bar
    (function makeDraggable(){
      let startX=0, startY=0, origLeft=0, origTop=0;
      videoWinBar.addEventListener('mousedown', (e) => {
        // If user interacts with a control (slider, button, input, label), do NOT start dragging
        const ctrl = (e.target && (e.target.closest && e.target.closest('input, button, label, select, textarea')));
        if (ctrl) return;
        draggingVideo = true; startX = e.clientX; startY = e.clientY;
        const rect = videoWindow.getBoundingClientRect(); origLeft = rect.left; origTop = rect.top;
        e.preventDefault();
        const mm = (ev) => {
          if (!draggingVideo) return;
          const dx = ev.clientX - startX, dy = ev.clientY - startY;
          videoWindow.style.left = Math.max(0, origLeft + dx) + 'px';
          videoWindow.style.top  = Math.max(0, origTop + dy) + 'px';
        };
        const mu = () => { draggingVideo = false; window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); };
        window.addEventListener('mousemove', mm);
        window.addEventListener('mouseup', mu);
      });
    })();
    btnShowVideo.onclick = () => { showVideoWindow(); };
    btnCloseVideo.onclick = () => { hideVideoWindow(); };
    btnMaximizeVideo.onclick = () => {
      if (!isMaximized) {
        // Save current rect
        const r = videoWindow.getBoundingClientRect();
        savedRect = { left: r.left, top: r.top, width: r.width, height: r.height };
        // Maximize to cover visualizer (viewport)
        videoWindow.style.left = '0px';
        videoWindow.style.top = '0px';
        videoWindow.style.width = window.innerWidth + 'px';
        videoWindow.style.height = window.innerHeight + 'px';
        isMaximized = true;
        videoWindow.classList.add('maximized');
      } else {
        // Restore
        if (savedRect) {
          videoWindow.style.left = savedRect.left + 'px';
          videoWindow.style.top = savedRect.top + 'px';
          videoWindow.style.width = savedRect.width + 'px';
          videoWindow.style.height = savedRect.height + 'px';
        }
        isMaximized = false;
        btnRestoreVideo.style.display = 'none';
        videoWindow.classList.remove('maximized');
      }
    };
    btnRestoreVideo.onclick = () => {
      if (isMaximized && savedRect) {
        videoWindow.style.left = savedRect.left + 'px';
        videoWindow.style.top = savedRect.top + 'px';
        videoWindow.style.width = savedRect.width + 'px';
        videoWindow.style.height = savedRect.height + 'px';
        isMaximized = false;
        btnRestoreVideo.style.display = 'none';
        videoWindow.classList.remove('maximized');
      }
    };
    // Ensure slider interaction doesn't bubble to the drag handler
    videoOpacity.addEventListener('mousedown', (e) => { e.stopPropagation(); });
    videoOpacity.addEventListener('pointerdown', (e) => { e.stopPropagation(); });
    videoOpacity.addEventListener('touchstart', (e) => { e.stopPropagation(); }, { passive: true });
    function applyVideoTransparency(){
      let tr = parseFloat(videoOpacity.value ?? '0'); // 0 => fully solid, up to 0.8 => 80% transparent
      if (!isFinite(tr) || tr < 0) { tr = 0; videoOpacity.value = '0'; }
      if (tr > 0.8) { tr = 0.8; videoOpacity.value = '0.8'; }
      const op = 1 - tr; // opacity is inverted transparency
      videoWindow.style.opacity = String(op);
    }
    videoOpacity.addEventListener('input', applyVideoTransparency);
    videoOpacity.addEventListener('change', applyVideoTransparency);
    // Apply once when showing the window (in case browser ignores min)
    applyVideoTransparency();
    function startOverlaySync(){ if (overlaySyncTimer) return; overlaySyncTimer = setInterval(syncOverlayNow, 600); }
    function stopOverlaySync(){ if (!overlaySyncTimer) return; clearInterval(overlaySyncTimer); overlaySyncTimer = 0; }
    function syncOverlayNow(){
      if (videoWindow.style.display === 'none') return;
      const item = state.playlist[currentIndex];
      if (!item) return;
      if (item.type === 'audio') {
        videoNoContent.style.display = 'flex';
        try { overlayPlayer && overlayPlayer.stopVideo && overlayPlayer.stopVideo(); } catch {}
        stopOverlayVideoFile();
        return;
      }
      videoNoContent.style.display = 'none';
      if (item.type === 'videoFile') {
        // Show local video element, hide YT iframe
        try { document.getElementById('videoOverlayPlayer').style.display = 'none'; } catch {}
        overlayHtmlVideo.style.display = '';
        // Ensure src is current
        if (overlayHtmlVideo.src !== item.url) { overlayHtmlVideo.src = item.url; }
        // Keep playing if main media running
        try {
          const playing = !(overlayHtmlVideo.paused || overlayHtmlVideo.ended);
          const frac = parseInt(seek.value||'0',10)/100; const d = overlayHtmlVideo.duration||0; if (d>0) {
            const target = d*frac; if (Math.abs((overlayHtmlVideo.currentTime||0) - target) > 1.0) overlayHtmlVideo.currentTime = target;
          }
          if (!playing && btnPlay.textContent === '⏸') overlayHtmlVideo.play();
        } catch {}
        return;
      }
      ensureOverlayPlayer(); if (!overlayPlayer) return;
      try { overlayPlayer.mute(); } catch {}
      try { document.getElementById('videoOverlayPlayer').style.display = ''; } catch {}
      overlayHtmlVideo.style.display = 'none';
      if (ytPlayer && typeof ytPlayer.getVideoData === 'function') {
        const data = ytPlayer.getVideoData(); const vid = data && data.video_id;
        const t = (ytPlayer.getCurrentTime && ytPlayer.getCurrentTime()) || 0;
        if (vid) {
          // Load video if different
          try {
            const odata = overlayPlayer.getVideoData && overlayPlayer.getVideoData();
            if (!odata || odata.video_id !== vid) {
              overlayPlayer.loadVideoById(vid, Math.floor(t));
            } else {
              const ot = overlayPlayer.getCurrentTime && overlayPlayer.getCurrentTime();
              if (Math.abs((ot||0) - t) > 1.2) overlayPlayer.seekTo(t, true);
            }
          } catch {}
          // Match play/pause
          try {
            const P = YT.PlayerState; const s = ytPlayer.getPlayerState();
            if (s === P.PLAYING) overlayPlayer.playVideo && overlayPlayer.playVideo();
            else if (s === P.PAUSED) overlayPlayer.pauseVideo && overlayPlayer.pauseVideo();
          } catch {}
        }
      }
    }

    // -----------------------
    // Livestream (camera) window wiring
    // -----------------------
    const obsWindow = document.getElementById('obsWindow');
    const liveWinBar = document.getElementById('liveWinBar');
    const btnCloseLive = document.getElementById('btnCloseLive');
    const btnMaximizeLive = document.getElementById('btnMaximizeLive');
    const btnRestoreLive = document.getElementById('btnRestoreLive');
    const liveOpacityBar = document.getElementById('liveOpacityBar');
    const liveVideo = document.getElementById('liveVideo');
    const liveDevice = document.getElementById('liveDevice');
    const liveRefresh = document.getElementById('liveRefresh');
    const btnShowLive = document.getElementById('btnShowLive');
    const liveOpacity = document.getElementById('liveOpacity');

    let liveIsMax = false; let liveSavedRect = null; let liveChromeTimer = 0; let draggingLive = false; let liveStream = null;

    function showObsWindow(){
      obsWindow.style.display = '';
      obsWindow.classList.remove('chrome-hidden');
      obsWindow.classList.remove('maximized');
      scheduleLiveChromeHide();
      try { document.body.classList.add('cursor-on'); document.documentElement.classList.add('cursor-on'); } catch {}
      applyLiveTransparency();
    }
    function hideObsWindow(){
      obsWindow.style.display = 'none';
      try { document.body.classList.remove('cursor-on'); document.documentElement.classList.remove('cursor-on'); } catch {}
      try { if (liveStream) { liveStream.getTracks().forEach(t => t.stop()); liveStream = null; liveVideo.srcObject = null; } } catch {}
      liveIsMax = false; liveSavedRect = null; btnRestoreLive.style.display = 'none';
      obsWindow.classList.remove('maximized');
    }
    function scheduleLiveChromeHide(){ if (liveChromeTimer) clearTimeout(liveChromeTimer); liveChromeTimer = setTimeout(() => { obsWindow.classList.add('chrome-hidden'); }, 3000); }
    function showLiveChrome(){ if (liveChromeTimer) clearTimeout(liveChromeTimer); obsWindow.classList.remove('chrome-hidden'); scheduleLiveChromeHide(); }
    obsWindow.addEventListener('mouseenter', showLiveChrome);
    obsWindow.addEventListener('mousemove', showLiveChrome);
    obsWindow.addEventListener('mouseleave', () => { if (liveChromeTimer) clearTimeout(liveChromeTimer); obsWindow.classList.add('chrome-hidden'); });
    // make live window draggable by its bar
    (function(){
      let startX=0, startY=0, origLeft=0, origTop=0;
      liveWinBar?.addEventListener('mousedown', (e) => {
        const ctrl = (e.target && (e.target.closest && e.target.closest('input, button, label, select, textarea')));
        if (ctrl) return;
        draggingLive = true; startX = e.clientX; startY = e.clientY;
        const rect = obsWindow.getBoundingClientRect(); origLeft = rect.left; origTop = rect.top;
        e.preventDefault();
        const mm = (ev) => { if (!draggingLive) return; const dx = ev.clientX - startX, dy = ev.clientY - startY; obsWindow.style.left = Math.max(0, origLeft + dx) + 'px'; obsWindow.style.top = Math.max(0, origTop + dy) + 'px'; };
        const mu = () => { draggingLive = false; window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); };
        window.addEventListener('mousemove', mm);
        window.addEventListener('mouseup', mu);
      });
    })();
    // Proximity-based restore
    obsWindow.addEventListener('mousemove', (e) => {
      if (!liveIsMax) { btnRestoreLive.style.display = 'none'; return; }
      const r = obsWindow.getBoundingClientRect(); const cx = r.left + r.width/2; const cy = r.top;
      const dx = Math.abs(e.clientX - cx), dy = Math.abs(e.clientY - cy);
      btnRestoreLive.style.display = (dx < 200 && dy < 90) ? '' : 'none';
    });
    btnCloseLive?.addEventListener('click', hideObsWindow);
    btnMaximizeLive?.addEventListener('click', () => {
      if (!liveIsMax) {
        const r = obsWindow.getBoundingClientRect(); liveSavedRect = { left: r.left, top: r.top, width: r.width, height: r.height };
        obsWindow.style.left = '0px'; obsWindow.style.top = '0px'; obsWindow.style.width = window.innerWidth + 'px'; obsWindow.style.height = window.innerHeight + 'px';
        obsWindow.classList.add('maximized'); liveIsMax = true;
      } else {
        if (liveSavedRect) { obsWindow.style.left = liveSavedRect.left + 'px'; obsWindow.style.top = liveSavedRect.top + 'px'; obsWindow.style.width = liveSavedRect.width + 'px'; obsWindow.style.height = liveSavedRect.height + 'px'; }
        obsWindow.classList.remove('maximized'); liveIsMax = false; btnRestoreLive.style.display = 'none';
      }
    });
    btnRestoreLive?.addEventListener('click', () => {
      if (liveIsMax && liveSavedRect) {
        obsWindow.style.left = liveSavedRect.left + 'px'; obsWindow.style.top = liveSavedRect.top + 'px'; obsWindow.style.width = liveSavedRect.width + 'px'; obsWindow.style.height = liveSavedRect.height + 'px';
        obsWindow.classList.remove('maximized'); liveIsMax = false; btnRestoreLive.style.display = 'none';
      }
    });
    function applyLiveTransparency(){
      let tr = parseFloat((liveOpacityBar?.value ?? liveOpacity?.value) ?? '0');
      if (!isFinite(tr) || tr < 0) tr = 0;
      if (tr > 0.8) tr = 0.8;
      if (liveOpacityBar) liveOpacityBar.value = String(tr);
      obsWindow.style.opacity = String(1 - tr);
    }
    if (liveOpacityBar) { ['mousedown','pointerdown','touchstart'].forEach(evt => liveOpacityBar.addEventListener(evt, e => e.stopPropagation(), { passive: true })); liveOpacityBar.addEventListener('input', applyLiveTransparency); liveOpacityBar.addEventListener('change', applyLiveTransparency); }
    if (liveOpacity) { ['mousedown','pointerdown','touchstart'].forEach(evt => liveOpacity.addEventListener(evt, e => e.stopPropagation(), { passive: true })); liveOpacity.addEventListener('input', applyLiveTransparency); liveOpacity.addEventListener('change', applyLiveTransparency); }

    async function ensureCameraPermission() {
      // getUserMedia prompt to reveal device labels and grant permission
      try {
        const tmp = await navigator.mediaDevices.getUserMedia({ video: true });
        tmp.getTracks().forEach(t => t.stop());
        return true;
      } catch (e) {
        console.warn('Camera permission denied', e);
        return false;
      }
    }
    async function ensureCameraPermissionFor(deviceId) {
      try {
        const tmp = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: deviceId } } });
        tmp.getTracks().forEach(t => t.stop());
        return true;
      } catch (e) {
        console.warn('Permission for device failed', e);
        return false;
      }
    }
    async function enumerateCameras(preserveSelection = true){
      try {
        const prev = preserveSelection ? (liveDevice?.value || '') : '';
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        liveDevice.innerHTML = '';
        vids.forEach((d, i) => { const opt = document.createElement('option'); opt.value = d.deviceId; opt.textContent = d.label || `Camera ${i+1}`; liveDevice.appendChild(opt); });
        // If labels are empty (no permission yet), try prompting once, then re-enumerate for labels
        const anyLabel = vids.some(d => (d.label||'').trim().length > 0);
        if (!anyLabel) {
          const ok = await ensureCameraPermission();
          if (ok) {
            // Re-enumerate to populate labels
            return enumerateCameras(preserveSelection);
          }
        }
        // Try to restore previous selection
        if (preserveSelection && prev) {
          const idx = Array.from(liveDevice.options).findIndex(o => o.value === prev);
          if (idx >= 0) liveDevice.selectedIndex = idx;
        }
        // If nothing selected, prefer OBS if available, otherwise first device
        if (liveDevice.selectedIndex < 0 && liveDevice.options.length) {
          const obsIdx = vids.findIndex(d => /obs|virtual/i.test(d.label||''));
          liveDevice.selectedIndex = obsIdx >= 0 ? obsIdx : 0;
        }
      } catch (e) { console.warn('enumerateCameras error', e); }
    }
    async function startLiveStream(){
      // Stop previous
      try { if (liveStream) { liveStream.getTracks().forEach(t => t.stop()); } } catch {}
      liveStream = null; liveVideo.srcObject = null;
      const id = liveDevice.value || undefined;
      try {
        // 1) Open the device with minimal constraints so the browser negotiates any supported format
        const baseConstraints = id ? { video: { deviceId: { exact: id } } } : { video: true };
        const stream = await navigator.mediaDevices.getUserMedia(baseConstraints);
        liveStream = stream; liveVideo.srcObject = stream; await liveVideo.play();
        // 2) Soft-tune with applyConstraints using 'ideal' within capabilities (if supported)
        const track = stream.getVideoTracks && stream.getVideoTracks()[0];
        const caps = track && track.getCapabilities ? track.getCapabilities() : null;
        if (track && caps) {
          const desired = {};
          // Prefer up to 60fps if available; otherwise use the max available
          if (caps.frameRate && (caps.frameRate.max || caps.frameRate.min)) {
            const maxFps = caps.frameRate.max || 30;
            desired.frameRate = { ideal: Math.min(60, maxFps) };
          }
          // Prefer up to 1920x1080 if available
          if (caps.width && (caps.width.max || caps.width.min)) {
            const w = Math.min(1920, caps.width.max || 1920);
            desired.width = { ideal: w };
          }
          if (caps.height && (caps.height.max || caps.height.min)) {
            const h = Math.min(1080, caps.height.max || 1080);
            desired.height = { ideal: h };
          }
          if (Object.keys(desired).length) {
            try { await track.applyConstraints(desired); } catch (e) { console.debug('applyConstraints ignored', e); }
          }
        }
      } catch (e) {
        console.error('Adaptive start failed', e);
        alert('Unable to start camera. Please allow access or choose another device.');
      }
    }
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      liveRefresh?.addEventListener('click', async () => { await enumerateCameras(true); });
      btnShowLive?.addEventListener('click', async () => {
        const ok = await ensureCameraPermission();
        if (!ok) { alert('Camera permission is required. Please allow access in your browser.'); return; }
        await enumerateCameras(true);
        if (!liveDevice.value && liveDevice.options.length) liveDevice.selectedIndex = 0;
        await startLiveStream();
        showObsWindow();
      });
      // When user changes camera source, prompt for permission for that specific device if needed,
      // then restart stream immediately if window is open or a stream exists
      liveDevice?.addEventListener('change', async () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
        // If window is visible or we already have a stream, swap to the new device
        const visible = obsWindow && obsWindow.style.display !== 'none';
        const id = liveDevice.value;
        // Try to explicitly request this device to trigger permission prompt if needed
        const ok = await ensureCameraPermissionFor(id);
        if (!ok) {
          alert('Camera permission is required for the selected device. Please allow access in your browser.');
          return;
        }
        await enumerateCameras(true);
        if (visible || liveStream) {
          try { await startLiveStream(); } catch (e) { console.error('Failed to switch camera', e); }
        }
      });
    } else {
      if (btnShowLive) btnShowLive.disabled = true;
    }

    // When switching to Livestream mode, pre-enumerate devices for convenience and show list
    const origApplyModeLayout = applyModeLayout;
    applyModeLayout = function(){
      origApplyModeLayout();
      if (state.mode === 'live' && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        enumerateCameras(true);
        const list = document.getElementById('liveWindowsList'); if (list) list.style.display = '';
        // Mount right-side Kick section if not present
        try {
          const tpl = document.getElementById('liveRightTemplate');
          const rightExisting = document.getElementById('liveRight');
          if (tpl && !rightExisting && playlistMount) {
            const frag = tpl.content.cloneNode(true);
            playlistMount.appendChild(frag);
            // Initialize Kick UI values from storage
            const kickUrlInput = document.getElementById('kickUrl');
            const saved = localStorage.getItem('kick_url') || 'https://kick.com/ninetentwo';
            if (kickUrlInput) kickUrlInput.value = saved;
            wireKickControls();
          }
          // Auto-launch last kick/VDO URLs if any
          autoLaunchKickIfNeeded();
          autoLaunchVdoIfNeeded();
        } catch {}
      } else {
        const list = document.getElementById('liveWindowsList'); if (list) list.style.display = 'none';
        // Remove/hide Kick right panel when leaving Livestream mode
        const rightExisting = document.getElementById('liveRight');
        if (rightExisting && rightExisting.parentElement === playlistMount) {
          rightExisting.remove();
        }
        // Keep kick window visible across modes
      }
    };

    // -----------------------
    // Multi-window Live Manager
    // -----------------------
    const liveWindowsList = document.getElementById('liveWindowsList');
    const btnNewLive = document.getElementById('btnNewLive');
    let liveZTop = 3500;
    const liveWindows = [];
    function nextLiveName(){ let i=1; while (liveWindows.some(w => w.name === `Live ${i}`)) i++; return `Live ${i}`; }
    function bringToFront(win){ try { win.root.style.zIndex = String(++liveZTop); } catch {} }
    function makeDraggableBar(win){
      let startX=0, startY=0, origLeft=0, origTop=0, dragging=false;
      win.bar.addEventListener('mousedown', (e) => {
        const ctrl = e.target && e.target.closest && e.target.closest('input, button, label, select, textarea');
        if (ctrl) return; dragging = true; bringToFront(win);
        startX = e.clientX; startY = e.clientY; const r = win.root.getBoundingClientRect(); origLeft = r.left; origTop = r.top; e.preventDefault();
        const mm = (ev) => { if (!dragging) return; const dx = ev.clientX - startX, dy = ev.clientY - startY; win.root.style.left = Math.max(0, origLeft + dx) + 'px'; win.root.style.top = Math.max(0, origTop + dy) + 'px'; win.root.style.right = 'auto'; };
        const mu = () => { dragging=false; window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); };
        window.addEventListener('mousemove', mm); window.addEventListener('mouseup', mu);
      });
    }
    function updatePlaylistCounts(){
      try {
        const all = state.playlist.length;
        const yt  = state.playlist.filter(it => it && (it.type === 'video' || it.type === 'playlist')).length;
        const aud = state.playlist.filter(it => it && it.type === 'audio' && !!it.local).length;
        const vid = state.playlist.filter(it => it && it.type === 'videoFile' && !!it.local).length;
        const elYT = document.getElementById('countYT');
        const elA  = document.getElementById('countAudio');
        const elV  = document.getElementById('countVideo');
        const elAll= document.getElementById('countAll');
        if (elYT) elYT.textContent = String(yt);
        if (elA)  elA.textContent  = String(aud);
        if (elV)  elV.textContent  = String(vid);
        if (elAll)elAll.textContent= String(all);
      } catch {}
    }
    function attachChrome(win){
      // auto-hide chrome
      let timer = 0; const schedule = () => { if (timer) clearTimeout(timer); timer = setTimeout(() => win.root.classList.add('chrome-hidden'), 3000); };
      const show = () => { if (timer) clearTimeout(timer); win.root.classList.remove('chrome-hidden'); schedule(); };
      win.root.addEventListener('mouseenter', show); win.root.addEventListener('mousemove', show);
      win.root.addEventListener('mouseleave', () => { if (timer) clearTimeout(timer); win.root.classList.add('chrome-hidden'); });
      // proximity restore
      win.root.addEventListener('mousemove', (e) => {
        if (!win.isMax) { win.restore.style.display = 'none'; return; }
        const r = win.root.getBoundingClientRect(); const cx = r.left + r.width/2, cy = r.top; const dx = Math.abs(e.clientX-cx), dy=Math.abs(e.clientY-cy);
        win.restore.style.display = (dx<200 && dy<90) ? '' : 'none';
      });
      win.maxBtn.addEventListener('click', () => {
        if (!win.isMax) { const r = win.root.getBoundingClientRect(); win.savedRect = {left:r.left, top:r.top, width:r.width, height:r.height};
          win.root.style.left='0px'; win.root.style.top='0px'; win.root.style.right='auto'; win.root.style.width=window.innerWidth+'px'; win.root.style.height=window.innerHeight+'px'; win.root.classList.add('maximized'); win.isMax = true; bringToFront(win);
        } else { if (win.savedRect){ win.root.style.left=win.savedRect.left+'px'; win.root.style.top=win.savedRect.top+'px'; win.root.style.width=win.savedRect.width+'px'; win.root.style.height=win.savedRect.height+'px'; }
          win.root.classList.remove('maximized'); win.isMax=false; win.restore.style.display='none'; }
      });
      win.restore.addEventListener('click', () => { if (win.isMax && win.savedRect){ win.root.style.left=win.savedRect.left+'px'; win.root.style.top=win.savedRect.top+'px'; win.root.style.width=win.savedRect.width+'px'; win.root.style.height=win.savedRect.height+'px'; win.root.classList.remove('maximized'); win.isMax=false; win.restore.style.display='none'; } });
      win.closeBtn.addEventListener('click', () => { hideLiveWindow(win); });
      win.opacity.addEventListener('mousedown', e => e.stopPropagation());
      win.opacity.addEventListener('input', () => { let tr = parseFloat(win.opacity.value||'0'); if (!isFinite(tr)||tr<0) tr=0; if (tr>0.8) tr=0.8; win.opacity.value=String(tr); win.root.style.opacity=String(1-tr); });
    }
    async function startLiveStreamFor(win, deviceId){
      try { if (win.stream) { win.stream.getTracks().forEach(t=>t.stop()); } } catch {}
      win.stream = null; win.video.srcObject = null;
      try {
        const base = deviceId ? { video: { deviceId: { exact: deviceId } } } : { video: true };
        const stream = await navigator.mediaDevices.getUserMedia(base);
        win.stream = stream; win.video.srcObject = stream; await win.video.play();
        const track = stream.getVideoTracks?.()[0]; const caps = track?.getCapabilities?.();
        if (track && caps) {
          const desired = {}; if (caps.frameRate?.max) desired.frameRate = { ideal: Math.min(60, caps.frameRate.max) };
          if (caps.width?.max) desired.width = { ideal: Math.min(1920, caps.width.max) };
          if (caps.height?.max) desired.height = { ideal: Math.min(1080, caps.height.max) };
          if (Object.keys(desired).length) { try { await track.applyConstraints(desired); } catch {} }
        }
      } catch (e) { console.error('startLiveStreamFor failed', e); alert('Unable to start the selected camera. Please allow access or choose another device.'); }
    }
    function showLiveWindow(win){ win.root.style.display=''; bringToFront(win); try { document.body.classList.add('cursor-on'); document.documentElement.classList.add('cursor-on'); } catch {} }
    function hideLiveWindow(win){ win.root.style.display='none'; try { document.body.classList.remove('cursor-on'); document.documentElement.classList.remove('cursor-on'); } catch {} }
    async function ensureDevicePermission(deviceId){ try{ const tmp=await navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:deviceId}}}); tmp.getTracks().forEach(t=>t.stop()); return true;}catch{return false;} }
    async function populateDeviceSelect(sel, chosen){ await enumerateCameras(true); sel.innerHTML = liveDevice.innerHTML; if (chosen){ const idx=[...sel.options].findIndex(o=>o.value===chosen); if (idx>=0) sel.selectedIndex=idx; } }
    function buildWindowDOM(name){
      const root = document.createElement('div'); root.className='video-window'; root.style.cssText='display:none; right:40px; left:auto; top:40px; z-index:'+ (++liveZTop);
      root.innerHTML = `
        <div class="chrome">
          <div class="title">${name}</div>
          <div class="spacer"></div>
          <label class="pill" title="Transparency">Transparency <input type="range" min="0" max="1" step="0.01" value="0.2" class="liveOpacity"></label>
          <button class="btnMax" title="Maximize over visualizer">🗖</button>
          <button class="btnClose" title="Close">✖</button>
        </div>
        <div class="content">
          <video autoplay playsinline muted style="width:100%; height:100%; object-fit:cover; background:#000;"></video>
          <button class="btnRestore" title="Restore window size" style="position:absolute; top:4px; left:50%; transform: translateX(-50%); display:none; z-index:5;">✖</button>
        </div>`;
      document.body.appendChild(root);
      const bar = root.querySelector('.chrome'); const video = root.querySelector('video'); const opacity = root.querySelector('.liveOpacity');
      const maxBtn = root.querySelector('.btnMax'); const closeBtn = root.querySelector('.btnClose'); const restore = root.querySelector('.btnRestore');
      const win = { id: crypto?.randomUUID?.() || (Date.now()+''+Math.random()), name, root, bar, video, opacity, maxBtn, closeBtn, restore, isMax:false, savedRect:null, stream:null, deviceId:null };
      makeDraggableBar(win); attachChrome(win); return win;
    }
    function renderLiveWindowsList(){ if (!liveWindowsList) return; liveWindowsList.style.display = ''; liveWindowsList.innerHTML='';
      if (liveWindows.length === 0) {
        const empty = document.createElement('div'); empty.style.opacity='0.7'; empty.style.fontSize='12px'; empty.textContent = 'No live windows yet. Click "New Live Window" to create one.'; liveWindowsList.appendChild(empty); return; }
      liveWindows.forEach((w) => {
      const row = document.createElement('div'); row.className='row'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.marginBottom='6px';
      const name = document.createElement('input'); name.type='text'; name.value = w.name; name.style.width='140px'; name.onchange = () => { w.name = name.value || w.name; const t = w.root.querySelector('.title'); if (t) t.textContent = w.name; };
      const sel = document.createElement('select'); sel.style.minWidth='180px'; populateDeviceSelect(sel, w.deviceId); sel.onchange = async () => { w.deviceId = sel.value; const ok = await ensureDevicePermission(w.deviceId); if (ok) { await startLiveStreamFor(w, w.deviceId); } else { alert('Please allow camera access for this device.'); } };
      const show = document.createElement('button'); show.textContent='Show'; show.onclick = async () => { if (!w.deviceId && sel.options.length){ sel.selectedIndex = sel.selectedIndex>=0? sel.selectedIndex:0; w.deviceId = sel.value; } if (w.deviceId) await startLiveStreamFor(w, w.deviceId); showLiveWindow(w); };
      const hide = document.createElement('button'); hide.textContent='Hide'; hide.onclick = () => hideLiveWindow(w);
      const remove = document.createElement('button'); remove.textContent='Remove'; remove.onclick = () => { try { if (w.stream) w.stream.getTracks().forEach(t=>t.stop()); } catch{}; try { w.root.remove(); } catch{}; const idx = liveWindows.indexOf(w); if (idx>=0) liveWindows.splice(idx,1); renderLiveWindowsList(); };
      row.appendChild(name); row.appendChild(sel); row.appendChild(show); row.appendChild(hide); row.appendChild(remove); liveWindowsList.appendChild(row);
    }); }
    function adoptOriginalObsWindow(){ if (!obsWindow) return; const name = nextLiveName(); const win = { id:'original', name, root: obsWindow, bar: liveWinBar, video: liveVideo, opacity: liveOpacityBar, maxBtn: btnMaximizeLive, closeBtn: btnCloseLive, restore: btnRestoreLive, isMax:false, savedRect:null, stream:null, deviceId: null };
      makeDraggableBar(win); attachChrome(win); liveWindows.push(win); renderLiveWindowsList(); }
    adoptOriginalObsWindow();
    // If the app is already in Livestream mode on load, show the list immediately
    if (state.mode === 'live' && liveWindowsList) { liveWindowsList.style.display=''; renderLiveWindowsList(); }
    btnNewLive?.addEventListener('click', async () => { const name = nextLiveName(); const win = buildWindowDOM(name); liveWindows.push(win); renderLiveWindowsList(); showLiveWindow(win); });

    // -----------------------
    // Kick.com floating window wiring
    // -----------------------
    const kickWindow = document.getElementById('kickWindow');
    const kickWinBar = document.getElementById('kickWinBar');
    const kickOpacity = document.getElementById('kickOpacity');
    const btnMaximizeKick = document.getElementById('btnMaximizeKick');
    const btnCloseKickWin = document.getElementById('btnCloseKickWin');
    const btnRestoreKick = document.getElementById('btnRestoreKick');
    const kickFrame = document.getElementById('kickFrame');
    let kickIsMax = false; let kickSavedRect = null; let kickChromeTimer = 0; let draggingKick = false;

    function normalizeKickUrl(u){
      try {
        const url = new URL(u.trim());
        // If user pasted regular channel URL like https://kick.com/username
        // convert to player embed: https://player.kick.com/username?autoplay=true
        if (url.hostname.includes('kick.com')) {
          const parts = url.pathname.split('/').filter(Boolean);
          const channel = parts[0] || 'ninetentwo';
          return `https://player.kick.com/${channel}?autoplay=true`;
        }
      } catch {}
      // Fallback: if already a player URL or something else, return as-is
      return u;
    }
    function applyKickTransparency(){ let tr = parseFloat(kickOpacity?.value ?? '0'); if (!isFinite(tr)||tr<0) tr=0; if (tr>0.8) tr=0.8; if (kickOpacity) kickOpacity.value=String(tr); kickWindow.style.opacity=String(1-tr); }
    function scheduleKickChromeHide(){ if (kickChromeTimer) clearTimeout(kickChromeTimer); kickChromeTimer = setTimeout(() => { kickWindow.classList.add('chrome-hidden'); }, 3000); }
    function showKickChrome(){ if (kickChromeTimer) clearTimeout(kickChromeTimer); kickWindow.classList.remove('chrome-hidden'); scheduleKickChromeHide(); }
    function showKickWindow(){ kickWindow.style.display=''; showKickChrome(); try{ document.body.classList.add('cursor-on'); document.documentElement.classList.add('cursor-on'); }catch{}; applyKickTransparency(); }
    function hideKickWindow(){ kickWindow.style.display='none'; try{ document.body.classList.remove('cursor-on'); document.documentElement.classList.remove('cursor-on'); }catch{} }
    if (kickWindow) {
      kickWindow.addEventListener('mouseenter', showKickChrome);
      kickWindow.addEventListener('mousemove', showKickChrome);
      kickWindow.addEventListener('mouseleave', () => { if (kickChromeTimer) clearTimeout(kickChromeTimer); kickWindow.classList.add('chrome-hidden'); });
      // Dragging on bar
      if (kickWinBar) {
        kickWinBar.addEventListener('mousedown', (e) => {
          const ctrl = e.target && e.target.closest && e.target.closest('input, button, label, select, textarea'); if (ctrl) return;
          draggingKick = true; const r = kickWindow.getBoundingClientRect(); const sx = e.clientX, sy = e.clientY; const ol = r.left, ot = r.top; e.preventDefault();
          const mm = (ev) => { if (!draggingKick) return; const dx=ev.clientX-sx, dy=ev.clientY-sy; kickWindow.style.left = Math.max(0, ol+dx)+'px'; kickWindow.style.top = Math.max(0, ot+dy)+'px'; kickWindow.style.right='auto'; };
          const mu = () => { draggingKick=false; window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', mu); };
          window.addEventListener('mousemove', mm); window.addEventListener('mouseup', mu);
        });
      }
      // Opacity slider guards
      if (kickOpacity) { ['mousedown','pointerdown','touchstart'].forEach(evt => kickOpacity.addEventListener(evt, e => e.stopPropagation(), { passive: true })); kickOpacity.addEventListener('input', applyKickTransparency); kickOpacity.addEventListener('change', applyKickTransparency); }
      // Max/restore
      if (btnMaximizeKick) btnMaximizeKick.addEventListener('click', () => {
        if (!kickIsMax) { const r = kickWindow.getBoundingClientRect(); kickSavedRect = { left:r.left, top:r.top, width:r.width, height:r.height };
          kickWindow.style.left='0px'; kickWindow.style.top='0px'; kickWindow.style.right='auto'; kickWindow.style.width=window.innerWidth+'px'; kickWindow.style.height=window.innerHeight+'px'; kickWindow.classList.add('maximized'); kickIsMax=true;
        } else { if (kickSavedRect){ kickWindow.style.left=kickSavedRect.left+'px'; kickWindow.style.top=kickSavedRect.top+'px'; kickWindow.style.width=kickSavedRect.width+'px'; kickWindow.style.height=kickSavedRect.height+'px'; }
          kickWindow.classList.remove('maximized'); kickIsMax=false; btnRestoreKick.style.display='none'; }
      });
      if (btnRestoreKick) btnRestoreKick.addEventListener('click', () => { if (kickIsMax && kickSavedRect){ kickWindow.style.left=kickSavedRect.left+'px'; kickWindow.style.top=kickSavedRect.top+'px'; kickWindow.style.width=kickSavedRect.width+'px'; kickWindow.style.height=kickSavedRect.height+'px'; kickWindow.classList.remove('maximized'); kickIsMax=false; btnRestoreKick.style.display='none'; } });
      kickWindow.addEventListener('mousemove', (e) => { if (!kickIsMax) { btnRestoreKick.style.display='none'; return; } const r = kickWindow.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top; const dx=Math.abs(e.clientX-cx), dy=Math.abs(e.clientY-cy); btnRestoreKick.style.display=(dx<200&&dy<90)?'':'none'; });
      if (btnCloseKickWin) btnCloseKickWin.addEventListener('click', () => { hideKickWindow(); });
    }

    function wireKickControls(){
      const kickUrlInput = document.getElementById('kickUrl');
      const btnOpenKick = document.getElementById('btnOpenKick');
      const btnCloseKick = document.getElementById('btnCloseKick');
      const btnOpenVdoPopup = document.getElementById('btnOpenVdoPopup');
      const btnOpenVdoWin = document.getElementById('btnOpenVdoWin');
      const vdoUrlInput = document.getElementById('vdoUrl');
      if (!kickUrlInput || !btnOpenKick || !btnCloseKick) return;
      btnOpenKick.onclick = () => {
        const raw = kickUrlInput.value || 'https://kick.com/ninetentwo';
        const norm = normalizeKickUrl(raw);
        localStorage.setItem('kick_url', raw);
        try { kickFrame.src = norm; } catch {}
        showKickWindow();
      };
      btnCloseKick.onclick = () => { hideKickWindow(); };
      // Plants: when opening Kick, refresh and spawn immediately
      if (btnOpenKick) {
        btnOpenKick.addEventListener('click', () => { if (state.plantsEnabled) { collectPlantTargets(); if (plantsTargets.length>0 && stems.length===0) spawnStem(); } });
      }
      if (btnOpenVdoPopup) {
        btnOpenVdoPopup.onclick = () => {
          const w = 1024, h = 720; const x = Math.max(0, (screen.width - w) / 2); const y = Math.max(0, (screen.height - h) / 2);
          window.open('https://vdo.ninja', 'vdo_ninja', `width=${w},height=${h},left=${x},top=${y},resizable=yes,scrollbars=yes`);
        };
      }
      if (btnOpenVdoWin && vdoUrlInput) {
        // Prefill from storage
        const savedVdo = localStorage.getItem('vdo_url'); if (savedVdo) vdoUrlInput.value = savedVdo;
        btnOpenVdoWin.onclick = () => {
          const raw = vdoUrlInput.value || 'https://vdo.ninja/?view=NfRGiBa';
          localStorage.setItem('vdo_url', raw);
          try { vdoFrame.src = raw; } catch {}
          showVdoWindow();
        };
      }
      const btnCloseVdo = document.getElementById('btnCloseVdo');
      if (btnCloseVdo) btnCloseVdo.onclick = () => hideVdoWindow();
    }

    // Auto-launch Kick stream when entering Livestream mode using last URL
    function autoLaunchKickIfNeeded(){
      if (state.mode !== 'live') return;
      const raw = localStorage.getItem('kick_url');
      if (!raw) return;
      const norm = normalizeKickUrl(raw);
      try { kickFrame.src = norm; } catch {}
      showKickWindow();
    }

    // -----------------------
    // VDO.Ninja floating window wiring
    // -----------------------
    const vdoWindow = document.getElementById('vdoWindow');
    const vdoWinBar = document.getElementById('vdoWinBar');
    const vdoOpacity = document.getElementById('vdoOpacity');
    const btnMaximizeVdo = document.getElementById('btnMaximizeVdo');
    const btnCloseVdoWin = document.getElementById('btnCloseVdoWin');
    const btnRestoreVdo = document.getElementById('btnRestoreVdo');
    const vdoFrame = document.getElementById('vdoFrame');
    let vdoIsMax = false; let vdoSavedRect = null; let vdoChromeTimer = 0; let draggingVdo = false;
    function applyVdoTransparency(){ let tr=parseFloat(vdoOpacity?.value??'0'); if(!isFinite(tr)||tr<0) tr=0; if(tr>0.8) tr=0.8; if(vdoOpacity) vdoOpacity.value=String(tr); vdoWindow.style.opacity=String(1-tr); }
    function scheduleVdoChromeHide(){ if(vdoChromeTimer) clearTimeout(vdoChromeTimer); vdoChromeTimer=setTimeout(()=>{ vdoWindow.classList.add('chrome-hidden'); },3000); }
    function showVdoChrome(){ if(vdoChromeTimer) clearTimeout(vdoChromeTimer); vdoWindow.classList.remove('chrome-hidden'); scheduleVdoChromeHide(); }
    function showVdoWindow(){ vdoWindow.style.display=''; showVdoChrome(); try{ document.body.classList.add('cursor-on'); document.documentElement.classList.add('cursor-on'); }catch{}; applyVdoTransparency();
      // Plants: refresh targets and spawn immediately when a window appears
      if (state.plantsEnabled) { collectPlantTargets(); if (plantsTargets.length>0 && stems.length===0) spawnStem(); }
    }
    function hideVdoWindow(){ vdoWindow.style.display='none'; try{ document.body.classList.remove('cursor-on'); document.documentElement.classList.remove('cursor-on'); }catch{} }
    if (vdoWindow) {
      vdoWindow.addEventListener('mouseenter', showVdoChrome);
      vdoWindow.addEventListener('mousemove', showVdoChrome);
      vdoWindow.addEventListener('mouseleave', () => { if (vdoChromeTimer) clearTimeout(vdoChromeTimer); vdoWindow.classList.add('chrome-hidden'); });
      if (vdoWinBar) {
        vdoWinBar.addEventListener('mousedown', (e) => {
          const ctrl = e.target && e.target.closest && e.target.closest('input, button, label, select, textarea'); if (ctrl) return;
          draggingVdo = true; const r = vdoWindow.getBoundingClientRect(); const sx=e.clientX, sy=e.clientY; const ol=r.left, ot=r.top; e.preventDefault();
          const mm=(ev)=>{ if(!draggingVdo) return; const dx=ev.clientX-sx, dy=ev.clientY-sy; vdoWindow.style.left=Math.max(0,ol+dx)+'px'; vdoWindow.style.top=Math.max(0,ot+dy)+'px'; vdoWindow.style.right='auto'; vdoWindow.style.bottom='auto'; };
          const mu=()=>{ draggingVdo=false; window.removeEventListener('mousemove',mm); window.removeEventListener('mouseup',mu); };
          window.addEventListener('mousemove',mm); window.addEventListener('mouseup',mu);
        });
      }
      if (vdoOpacity) { ['mousedown','pointerdown','touchstart'].forEach(evt=>vdoOpacity.addEventListener(evt, e=>e.stopPropagation(), {passive:true})); vdoOpacity.addEventListener('input', applyVdoTransparency); vdoOpacity.addEventListener('change', applyVdoTransparency); }
      if (btnMaximizeVdo) btnMaximizeVdo.addEventListener('click', () => {
        if (!vdoIsMax) { const r=vdoWindow.getBoundingClientRect(); vdoSavedRect={left:r.left, top:r.top, width:r.width, height:r.height}; vdoWindow.style.left='0px'; vdoWindow.style.top='0px'; vdoWindow.style.right='auto'; vdoWindow.style.width=window.innerWidth+'px'; vdoWindow.style.height=window.innerHeight+'px'; vdoWindow.classList.add('maximized'); vdoIsMax=true; }
        else { if(vdoSavedRect){ vdoWindow.style.left=vdoSavedRect.left+'px'; vdoWindow.style.top=vdoSavedRect.top+'px'; vdoWindow.style.width=vdoSavedRect.width+'px'; vdoWindow.style.height=vdoSavedRect.height+'px'; } vdoWindow.classList.remove('maximized'); vdoIsMax=false; btnRestoreVdo.style.display='none'; }
      });
      if (btnRestoreVdo) btnRestoreVdo.addEventListener('click', ()=>{ if(vdoIsMax && vdoSavedRect){ vdoWindow.style.left=vdoSavedRect.left+'px'; vdoWindow.style.top=vdoSavedRect.top+'px'; vdoWindow.style.width=vdoSavedRect.width+'px'; vdoWindow.style.height=vdoSavedRect.height+'px'; vdoWindow.classList.remove('maximized'); vdoIsMax=false; btnRestoreVdo.style.display='none'; } });
      vdoWindow.addEventListener('mousemove', (e)=>{ if(!vdoIsMax){ btnRestoreVdo.style.display='none'; return; } const r=vdoWindow.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top; const dx=Math.abs(e.clientX-cx), dy=Math.abs(e.clientY-cy); btnRestoreVdo.style.display=(dx<200&&dy<90)?'':'none'; });
      if (btnCloseVdoWin) btnCloseVdoWin.addEventListener('click', ()=>{ hideVdoWindow(); });
    }

    // Auto-restore last VDO URL into iframe when entering Livestream mode
    function autoLaunchVdoIfNeeded(){
      if (state.mode !== 'live') return;
      const raw = localStorage.getItem('vdo_url');
      if (!raw) return;
      try { vdoFrame.src = raw; } catch {}
      showVdoWindow();
    }

    // Controls wiring
    btnCapture.onclick = () => { startCapture(); };
    if (btnReleaseAudio) btnReleaseAudio.onclick = () => { releaseAudio(); };
    if (btnResetVis) btnResetVis.onclick = () => { resetVisualizer(); };
    btnPurge.onclick = () => { localStorage.removeItem(LS_KEY); location.reload(); };
    // --- YouTube Music Search Modal ---
    function openYtModal(){ ytSearchModal.classList.add('show'); }
    function closeYtModal(){ ytSearchModal.classList.remove('show'); if (ytPreview){ ytPreview.innerHTML=''; ytPreview.style.display='none'; } }
    btnSearchYT.onclick = () => { openYtModal(); };
    btnCloseYtModal.onclick = () => { closeYtModal(); };
    // Prefill API key from localStorage (separate from visualizer state)
    const LS_YT_KEY = 'yt_api_key';
    ytApiKeyInput.value = localStorage.getItem(LS_YT_KEY) || '';
    btnSaveApiKey.onclick = () => { localStorage.setItem(LS_YT_KEY, ytApiKeyInput.value.trim()); alert('API key saved locally.'); };
    btnOpenApiKeyGuide.onclick = () => {
      const url = 'https://console.cloud.google.com/apis/api/youtube.googleapis.com/credentials?project=central-weft-195200';
      window.open(url, 'ytApiKeyWindow', 'width=1280,height=900,resizable=yes,scrollbars=yes,noopener');
    };

    function setYtPreview(vid){
      if (!ytPreview) return;
      ytPreview.style.display = '';
      ytPreview.innerHTML = '';
      const iframe = document.createElement('iframe');
      iframe.width = '100%';
      iframe.height = '360';
      iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
      iframe.referrerPolicy = 'strict-origin-when-cross-origin';
      // Mute preview to avoid overlapping audio with the main player
      iframe.src = `https://www.youtube.com/embed/${vid}?autoplay=1&rel=0&modestbranding=1&playsinline=1&mute=1`;
      iframe.style.border = '0';
      ytPreview.appendChild(iframe);
    }

    async function runYtMusicSearch(){
      const key = ytApiKeyInput.value.trim() || localStorage.getItem(LS_YT_KEY) || '';
      const q = ytQuery.value.trim();
      ytResults.innerHTML = '';
      if (!key) { ytResults.textContent = 'Provide an API key first.'; return; }
      if (!q) { ytResults.textContent = 'Enter a search term.'; return; }
      // Search list: videos, channel type=video, safeSearch=none; we will filter to videoCategoryId=10 (Music) via Videos API
      try {
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=15&q=${encodeURIComponent(q)}&key=${encodeURIComponent(key)}`;
        const sr = await fetch(searchUrl);
        if (!sr.ok) throw new Error('Search HTTP '+sr.status);
        const sj = await sr.json();
        const ids = (sj.items||[]).map(it => it.id && it.id.videoId).filter(Boolean);
        if (!ids.length) { ytResults.textContent = 'No results.'; return; }
        const videosUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${ids.join(',')}&key=${encodeURIComponent(key)}`;
        const vr = await fetch(videosUrl);
        if (!vr.ok) throw new Error('Videos HTTP '+vr.status);
        const vj = await vr.json();
        const music = (vj.items||[]).filter(v => (v.snippet && String(v.snippet.categoryId) === '10'));
        if (!music.length) { ytResults.textContent = 'No music-tagged results.'; return; }
        // Render results with thumbnails and Play/Add
        music.forEach(v => {
          const vid = v.id; const sn = v.snippet || {}; const title = sn.title || 'Untitled'; const ch = sn.channelTitle || '';
          const thumb = sn.thumbnails && (sn.thumbnails.medium || sn.thumbnails.default || sn.thumbnails.high);
          const row = document.createElement('div'); row.className = 'row'; row.style.alignItems = 'center';
          const img = document.createElement('img'); if (thumb && thumb.url) { img.src = thumb.url; img.width = 120; img.height = 67; img.style.objectFit = 'cover'; img.style.borderRadius = '6px'; img.style.marginRight = '8px'; }
          const meta = document.createElement('div'); meta.className = 'grow';
          const t = document.createElement('div'); t.textContent = title; t.style.fontWeight = '700';
          const c = document.createElement('div'); c.textContent = ch; c.style.opacity = '0.8'; c.style.fontSize = '12px';
          meta.appendChild(t); meta.appendChild(c);
          const play = document.createElement('button'); play.textContent = 'Play'; play.onclick = () => setYtPreview(vid);
          const add = document.createElement('button'); add.textContent = 'Add'; add.onclick = () => {
            const wasEmpty = state.playlist.length === 0;
            state.playlist.push({ type:'video', id: vid, title }); saveState(); renderPlaylist();
            if (wasEmpty && ytPlayer) loadIntoPlayer();
            // Stop preview playback and keep user focused on the main player
            if (ytPreview){ ytPreview.innerHTML=''; ytPreview.style.display='none'; }
          };
          if (thumb && thumb.url) row.appendChild(img);
          row.appendChild(meta);
          row.appendChild(play);
          row.appendChild(add);
          ytResults.appendChild(row);
        });
      } catch (err) {
        console.error(err); ytResults.textContent = 'Error: ' + (err.message||err);
      }
    }
    btnRunYtSearch.onclick = () => { runYtMusicSearch(); };
    btnExport.onclick = () => {
      const blob = new Blob([JSON.stringify(getSavableState(), null, 2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'visual_settings.json'; a.click();
    };
    // Import uses hidden input (overwrite localStorage)
    document.querySelector('label input#importJson').addEventListener('change', (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      const reader = new FileReader(); reader.onload = () => {
        try {
          const obj = JSON.parse(reader.result);
          // Write raw JSON to storage under our LS_KEY to fully overwrite
          localStorage.setItem(LS_KEY, JSON.stringify(obj));
          location.reload();
        } catch {}
      }; reader.readAsText(file);
    });

    function applyModeLayout() {
      const isPlayer = (state.mode === 'player');
      // Update body mode class for CSS guards
      try {
        document.body.classList.remove('mode-player', 'mode-messages', 'mode-live');
        document.body.classList.add(
          state.mode === 'player' ? 'mode-player' : (state.mode === 'messages' ? 'mode-messages' : 'mode-live')
        );
      } catch {}
      // Always show capture button in all modes
      btnCapture.style.display = '';
      // In player mode, show playlist; in message center, use right column to show entire messages section
      if (isPlayer) {
        playlistSection.style.display = '';
        playlistSection.classList.remove('peek');
        if (playlistDiv.parentElement !== playlistMount) {
          playlistMount.appendChild(playlistDiv);
        }
        if (playlistHeaderEl) playlistHeaderEl.textContent = 'Playlist';
        // Show original playlist list
        playlistDiv.style.display = '';
        // Restore entire messages section to its original home, hide it in player mode
        if (messagesSection.parentElement !== messagesSectionHome) {
          messagesSectionHome.appendChild(messagesSection);
        }
        messagesSection.style.display = 'none';
        if (msgPreviewRow) { msgPreviewRow.style.display = 'none'; }
        if (msgPreviewBox) { msgPreviewBox.innerHTML = ''; }
        if (liveControlsRow) { liveControlsRow.style.display = 'none'; }
        // Hide Livestream windows list and right-side panel if present
        const __lw = document.getElementById('liveWindowsList'); if (__lw) __lw.style.display = 'none';
        const __lr = document.getElementById('liveRight'); if (__lr && __lr.parentElement === playlistMount) { __lr.remove(); }
        // Show all player rows except the preview row and the livestream camera controls row
        const rows = playerSection.querySelectorAll('.row');
        rows.forEach(r => {
          if (r.id === 'msgPreviewRow' || r.id === 'liveControlsRow') r.style.display = 'none';
          else r.style.display = '';
        });
      } else if (state.mode === 'messages') {
        // Repurpose the right column to show the entire messages section (controls + list)
        playlistSection.style.display = '';
        playlistSection.classList.remove('peek');
        if (playlistHeaderEl) playlistHeaderEl.textContent = 'Messages';
        // Mount entire messages section into the right column area
        if (messagesSection.parentElement !== playlistMount) {
          playlistMount.innerHTML = '';
          playlistMount.appendChild(messagesSection);
        }
        messagesSection.style.display = '';
        // Never show the original playlist list in message center
        playlistDiv.style.display = 'none';
        if (liveControlsRow) { liveControlsRow.style.display = 'none'; }
        // Hide all player rows except the first (Mode/Capture row)
        const rows = playerSection.querySelectorAll('.row');
        rows.forEach((r, idx) => { r.style.display = (idx === 0 || r.id === 'msgPreviewRow') ? '' : 'none'; });
        if (msgPreviewRow) msgPreviewRow.style.display = '';
        updatePreview();
      } else if (state.mode === 'live') {
        // Livestream settings on left; right column neutral with title Livestream
        playlistSection.style.display = '';
        playlistSection.classList.remove('peek');
        if (playlistHeaderEl) playlistHeaderEl.textContent = 'Livestream';
        // Clear right column mount area
        playlistMount.innerHTML = '';
        // Left: show only mode row and live controls row
        if (messagesSection) messagesSection.style.display = 'none';
        if (msgPreviewRow) msgPreviewRow.style.display = 'none';
        const rows = playerSection.querySelectorAll('.row');
        rows.forEach((r, idx) => { r.style.display = (idx === 0 || r.id === 'liveControlsRow') ? '' : 'none'; });
        if (liveControlsRow) liveControlsRow.style.display = '';
      }
    }
    modeSelect.onchange = () => { state.mode = modeSelect.value; saveState(); applyModeLayout(); updatePreview(); updateOverlay(); };
    msgMode.onchange = () => { state.msgMode = msgMode.value; saveState(); updateMessageControlsVisibility(); updatePreview(); updateOverlay(); };
    btnEditMsg.onclick = () => { if (msgInput.value) { state.messages.unshift({ text: msgInput.value }); saveState(); renderMessages(); } };
    btnClearMsg.onclick = () => { msgInput.value=''; state.msgDraft = ''; saveState(); updatePreview(); updateOverlay(); };
    msgInput.oninput = () => { state.msgDraft = msgInput.value; saveState(); updatePreview(); updateOverlay(); };
    if (btnNewLine) btnNewLine.onclick = () => {
      const el = msgInput; const start = el.selectionStart ?? el.value.length; const end = el.selectionEnd ?? start;
      el.value = el.value.slice(0, start) + "\n" + el.value.slice(end);
      el.selectionStart = el.selectionEnd = start + 1; el.focus(); updatePreview(); updateOverlay();
    };
    msgInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.shiftKey) {
        e.preventDefault();
        const el = msgInput; const start = el.selectionStart ?? el.value.length; const end = el.selectionEnd ?? start;
        el.value = el.value.slice(0, start) + "\n" + el.value.slice(end);
        el.selectionStart = el.selectionEnd = start + 1; updatePreview(); updateOverlay();
      }
    });
    msgSize.onchange = () => { updatePreview(); updateOverlay(); };
    msgLine.oninput = () => {
      // Persist and apply to overlay CSS, then refresh preview and overlay renderers
      state.msgOptions.lineHeight = parseFloat(msgLine.value);
      saveState();
      applyMsgOptions();
      updatePreview();
      updateOverlay();
    };
    msgSpeed.onchange = () => { updatePreview(); };
    msgPos.onchange = () => { state.msgPos = msgPos.value; saveState(); applyMarqueePosition(); updatePreview(); };
    if (msgAlign) msgAlign.onchange = () => { state.msgAlign = msgAlign.value; saveState(); updatePreview(); updateOverlay(); };
    btnAdd.onclick = async () => {
      const text = addUrl.value.trim(); if (!text) return;
      const p = classifyUrl(text);
      if (!p) { alert('Unrecognized URL'); return; }
      const wasEmpty = state.playlist.length === 0;
      state.playlist.push(p);
      addUrl.value=''; saveState(); renderPlaylist();
      if (wasEmpty && ytPlayer) loadIntoPlayer(); // only load if nothing was playing before
    };
    // Local file add
    document.getElementById('btnAddFile').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const f = e.target.files?.[0]; if (!f) return;
      const url = URL.createObjectURL(f);
      lastLocalFileName = f.name; { const b = document.getElementById('btnReaddLocal'); if (b) b.disabled = false; }
      const isVideo = (f.type||'').startsWith('video/');
      state.playlist.push({ type: isVideo ? 'videoFile' : 'audio', url, name: f.name, local:true });
      saveState(); renderPlaylist();
    });
    // Re-add feature removed by user request; leave no-op guards to avoid errors if legacy state exists
    function updatePlayerButtonsUI(){
      // Active state visuals
      btnShuffle.classList.toggle('active', !!state.shuffle);
      btnRepeat.classList.toggle('active',  !!state.repeat);
      btnRepeat1.classList.toggle('active', !!state.repeat1);
      // Base opacity for readability even when off
      btnShuffle.style.opacity = state.shuffle ? 1 : 0.8;
      btnRepeat.style.opacity  = state.repeat  ? 1 : 0.8;
      // Repeat1 overrides the other two
      const overridden = !!state.repeat1;
      btnShuffle.disabled = overridden; btnRepeat.disabled = overridden;
      btnShuffle.classList.toggle('overridden', overridden);
      btnRepeat.classList.toggle('overridden', overridden);
      // Titles for clarity
      btnRepeat1.title = overridden ? 'Repeat current (overrides Shuffle/Repeat)' : 'Repeat current item only';
      btnShuffle.title = overridden ? 'Disabled by Repeat 1' : 'Shuffle';
      btnRepeat.title  = overridden ? 'Disabled by Repeat 1' : 'Repeat';
    }
    volume.oninput = () => { state.volume = parseFloat(volume.value); saveState(); try{ ytPlayer && ytPlayer.setVolume(Math.round(state.volume * 100)); }catch{} };
    btnShuffle.onclick = () => { if (state.repeat1) return; state.shuffle = !state.shuffle; resetPlayHistory(true); saveState(); updatePlayerButtonsUI(); if (ytPlayer) loadIntoPlayer(); };
    btnRepeat.onclick  = () => { if (state.repeat1) return; state.repeat  = !state.repeat;  saveState(); updatePlayerButtonsUI(); try{ ytPlayer && ytPlayer.setLoop(state.repeat); }catch{} };
    sensBass.oninput = () => { state.sensBass = parseFloat(sensBass.value); saveState(); };
    sensMid.oninput = () => { state.sensMid = parseFloat(sensMid.value); saveState(); };
    sensTreble.oninput = () => { state.sensTreble = parseFloat(sensTreble.value); saveState(); };
    sensPunchy.onchange = () => { state.sensPunchy = sensPunchy.checked; saveState(); };
    sensThunder.onchange = () => { state.sensThunder = sensThunder.checked; saveState(); };
    sensThunderIntensity.oninput = () => { state.sensThunderIntensity = parseFloat(sensThunderIntensity.value); saveState(); };

    // Playback controls
    btnPlay.onclick = async () => {
      if (!ytPlayer) return;
      if (state.mode === 'player') { togglePlay(); return; }
      const st = ytPlayer.getPlayerState(); const P = YT.PlayerState; if (st === P.PLAYING) ytPlayer.pauseVideo(); else ytPlayer.playVideo();
    };
    btnPrev.onclick = () => { prevItem(); };
    btnNext.onclick = () => { nextItem(); };
    function seekToFraction(f){
      const item = state.playlist[currentIndex]; if (!item) return;
      const frac = Math.min(1, Math.max(0, isFinite(f) ? f : 0));
      if (item.type === 'audio') {
        const d = audioEl.duration||0; if (d>0) { audioEl.currentTime = d * frac; }
      } else if (ytPlayer && typeof ytPlayer.seekTo === 'function') {
        if (item.type === 'video') {
          const d = (ytPlayer.getDuration && ytPlayer.getDuration()) || 0;
          const t = d>0 ? d * frac : (((ytPlayer.getCurrentTime && ytPlayer.getCurrentTime()) || 0));
          ytPlayer.seekTo(t, true);
        }
      } else if (item.type === 'videoFile') {
        const d = overlayHtmlVideo.duration||0; if (d>0) overlayHtmlVideo.currentTime = d * frac;
      }
      // Immediately sync overlay video window if open
      try { syncOverlayNow(); } catch {}
    }
    seek.oninput = () => {
      draggingSeek = true;
      const v = parseInt(seek.value||'0',10)/100; seekToFraction(v);
    };
    seek.onchange = () => {
      draggingSeek = false;
      const v = parseInt(seek.value||'0',10)/100; seekToFraction(v);
    };
    btnShuffle.onclick = () => { if (state.repeat1) return; state.shuffle = !state.shuffle; saveState(); updatePlayerButtonsUI(); };
    btnRepeat.onclick  = () => { if (state.repeat1) return; state.repeat  = !state.repeat;  saveState(); updatePlayerButtonsUI(); };
    if (btnRepeat1) {
      btnRepeat1.onclick = () => { state.repeat1 = !state.repeat1; resetPlayHistory(true); saveState(); updatePlayerButtonsUI(); };
    }

    // -----------------------
    // Audio reactive mapping
    // -----------------------
    let audioStrength = { bass: 0, mid: 0, treble: 0 };
    // Thunder effect state (treble-peak driven)
    let prevTreble = 0.0;
    let prevTrebleRaw = 0.0;
    let thunderEnergy = 0.0; // accumulates on peaks, decays over time
    let strobeEnergy = 0.0;  // very fast, for high-highs strobing
    let lastThunderSpawn = 0; // seconds, for cooldown between spawns
    // Bass-driven breathing scale for the instanced block grid
    let blockBreath = 1.0;
    function applyAudioToScene() {
      // Smooth
      const s = 0.12; // smoothing
      audioStrength.bass = THREE.MathUtils.lerp(audioStrength.bass, bands.bass, s);
      audioStrength.mid = THREE.MathUtils.lerp(audioStrength.mid, bands.mid, s);
      audioStrength.treble = THREE.MathUtils.lerp(audioStrength.treble, bands.treble, s);
      // Nonlinear sensitivity mapping for stronger extremes
      const sB = (state.sensBass ?? 1), sM = (state.sensMid ?? 1), sT = (state.sensTreble ?? 1);
      const baseB = audioStrength.bass * (sB * sB);
      const baseM = 2.0 * audioStrength.mid * (sM * sM); // doubled mid sensitivity
      const baseT = audioStrength.treble * Math.pow(sT, 1.5);
      const punch = state.sensPunchy ? 1.8 : 1.0; // extra punch across all bands
      const gB = baseB * punch;
      const gM = baseM * punch;
      const gT = baseT * punch;

      // Bass: fog density and scan-line brightness/thickness
      scene.fog.density = THREE.MathUtils.clamp(0.008 + gB * 0.12, 0.005, 0.16);
      // Bass: increase movement size of the blocks via a global breathing scale
      // Smoothly approach target to avoid jitter
      const targetBreath = 1.0 + gB * (state.sensPunchy ? 0.95 : 0.65); // more expansion when punchy
      blockBreath = THREE.MathUtils.lerp(blockBreath, targetBreath, 0.1);
      mesh.scale.setScalar(blockBreath);
      if (scan2Uniforms) {
        const pf = state.sensPunchy ? 1.4 : 1.0;
        scan2Uniforms.uGlow.value = 1.5 + gB * 6.0 * pf;
        scan2Uniforms.uThickness.value = 0.08 + gB * 0.25 * pf;
        scan2Uniforms.uSubThickness.value = 0.03 + gB * 0.12 * pf;
        // Thunder: gate scan glow by treble so it calms when highs are low
        if (state.sensThunder) {
          scan2Uniforms.uGlow.value *= THREE.MathUtils.clamp((gT - 0.08) / 0.25, 0.0, 1.0);
        }
      }
      if (scanWrapPass) {
        const pf2 = state.sensPunchy ? 1.35 : 1.0;
        scanWrapUniforms.glow.value = 1.4 + gB * 4.0 * pf2;
        // Audio-driven softness and motion
        const breathe = THREE.MathUtils.clamp(0.22 * gB + 0.15 * gM, 0.0, 0.9);
        scanWrapUniforms.breathe.value = breathe;
        const WR = (window.__DEV_WRAP || {gw:1,wob:1,noi:1,gwBoost:false,wobBoost:false,noiBoost:false});
        const gwMul = WR.gw * (WR.gwBoost ? 1.6 : 1.0);
        const wobMul = WR.wob * (WR.wobBoost ? 1.6 : 1.0);
        const noiMul = WR.noi * (WR.noiBoost ? 1.6 : 1.0);
        scanWrapUniforms.gaussWidth.value = (1.35 * (1.0 + 0.5 * gB)) * gwMul;
        scanWrapUniforms.noiseAmp.value = (0.04 * (0.6 + 0.8 * gT)) * noiMul;
        scanWrapUniforms.wobbleAmp.value = (0.04 * (0.6 + 0.6 * gM)) * wobMul;
        // Opacity mapping and gating
        scanWrapUniforms.opacity.value = 0.5 + gB * 0.5 * pf2; // 0.5..1.0
        if (state.sensThunder) {
          const gate = THREE.MathUtils.clamp((gT - 0.08) / 0.25, 0.0, 1.0);
          scanWrapUniforms.opacity.value *= gate;
        }
      }
      // Cube hit glow reacts to bass as well
      scanHitUniforms.uGlow.value = 1.4 + gB * 6.0;

      // Mid: shard velocity and grid rotation speed
      const rotPF = state.sensPunchy ? 1.5 : 1.0;
      gridGroup.rotation.y += 0.0006 + gM * 0.02 * rotPF;
      thinGridGroup.rotation.x += 0.0003 + gM * 0.015 * rotPF;
      thinGridGroup.rotation.z += 0.0002 + gM * 0.01 * rotPF;
      // Trails damping: lower damp = stronger trails when motion is high
      if (afterimage && afterimage.uniforms && afterimage.uniforms['damp']) {
        const baseDamp = THREE.MathUtils.clamp(0.95 - gM * 0.35, 0.45, 0.95);
        afterimage.uniforms['damp'].value = state.sensPunchy ? Math.max(0.40, baseDamp - 0.05) : baseDamp;
      }

      // Treble: bloom/exposure shimmer, embers and fireflies intensity and size
      const bloomPF = state.sensPunchy ? 1.35 : 1.0;
      // Base mapping (non-thunder)
      const baseBloom = 0.4 + gT * 2.2 * bloomPF;
      const baseExposure = THREE.MathUtils.clamp(1.0 + gT * 0.6 * bloomPF, 0.8, 2.2);
      // Thunder flash factor uses RAW treble (pre-sensitivity) for independence from treble slider
      const tRaw = bands.treble || 0.0; // instantaneous treble band
      const midRaw = bands.mid || 0.0;   // instantaneous mid band
      const tBroad = 0.75 * tRaw + 0.25 * midRaw; // include some mid-high harmonic energy
      // Abrupt gate: near-zero below low threshold, fast rise afterwards
      const lowT = 0.08, highT = 0.30;
      const gateHard = THREE.MathUtils.clamp((tBroad - lowT) / (highT - lowT), 0.0, 1.0);
      const gateSharp = Math.pow(gateHard, 2.2); // sharper knee
      // Ultra-high strobe when highest frequencies hit
      if (state.sensThunder && tRaw > 0.45) {
        strobeEnergy = Math.min(2.2, strobeEnergy + (tRaw - 0.45) * (1.1 + 1.1*state.sensThunderIntensity));
      }
      // Flash factor scales with thunderEnergy and Thunder Intensity, independent of treble sensitivity
      const flashFactor = state.sensThunder
        ? THREE.MathUtils.clamp(0.30 + gateSharp * (0.9 + 1.0*state.sensThunderIntensity) + thunderEnergy * (0.20 + 0.20*state.sensThunderIntensity), 0.15, 3.0)
        : 1.0;
      bloom.strength = baseBloom * flashFactor;
      // Apply ultra-fast strobe on exposure as a multiplier
      renderer.toneMappingExposure = THREE.MathUtils.clamp(baseExposure * flashFactor * (1.0 + strobeEnergy * 1.2), 0.7, 2.8);
      // Particles fade a bit on low treble and brighten on highs when Thunder is on (use raw)
      const gate = state.sensThunder ? gateSharp : 1.0;
      emberMaterial.opacity = THREE.MathUtils.clamp((0.15 + gT * 0.9 * bloomPF) * (0.5 + 0.5 * gate), 0.05, 1.0);
      if (emberMaterial.size !== undefined) {
        emberMaterial.size = THREE.MathUtils.clamp(4.0 + gT * 22.0 * bloomPF, 2.0, 32.0);
      }
      if (state.sensThunder) {
        fireflyMat.opacity = THREE.MathUtils.clamp((0.25 + gT * 1.2 * bloomPF) * (0.35 + 0.65 * gateSharp), 0.1, 1.0);
      } else {
        fireflyMat.opacity = THREE.MathUtils.clamp((0.25 + gT * 1.2 * bloomPF), 0.2, 1.0);
      }

      // Thunder: inject hard motion on treble peaks (not brightness-based)
      if (state.sensThunder) {
        // Use raw treble for peak detection so sensitivity slider does not suppress thunder
        const tDelta = Math.max(0, tRaw - prevTrebleRaw);
        const peak = (tRaw > 0.22) || (tDelta > 0.05);
        if (peak) {
          const kick = (tRaw * 1.1 + tDelta * 1.6) * (state.sensPunchy ? 1.5 : 1.0) * (0.8 + 1.0*state.sensThunderIntensity);
          thunderEnergy = Math.min(thunderEnergy + kick, 3.2);
          // Spawn right-angled lightning strikes
          const baseInt = (tRaw * 0.9 + thunderEnergy * 0.4) * (0.6 + 0.8*state.sensThunderIntensity);
          const count = Math.max(1, Math.min(3, Math.floor(1 + (tRaw + strobeEnergy * 0.6 + state.sensThunderIntensity*0.4) * 1.6)));
          for (let i=0;i<count;i++) spawnStrike(baseInt);
        }
        // Gate-based spawn to keep frequent strikes on sustained highs even without sharp deltas
        const tNow = clock.getElapsedTime();
        if (gateSharp > 0.35 && (tNow - lastThunderSpawn) > 0.12) {
          const baseInt2 = (gateSharp * 1.2 + thunderEnergy * 0.25) * (0.6 + 0.8*state.sensThunderIntensity);
          spawnStrike(baseInt2);
          lastThunderSpawn = tNow;
        }
        // Decay
        thunderEnergy *= (0.88 - 0.06 * Math.min(1, state.sensThunderIntensity-1));
        // Gentle accumulation from sustained highs so energy doesn't flatline
        thunderEnergy = Math.min(3.2, thunderEnergy + gateSharp * 0.02 * (0.8 + 0.7*state.sensThunderIntensity));
        strobeEnergy *= 0.55; // very fast decay for strobe

        if (thunderEnergy > 0.001 || gateSharp > 0.2) {
          const tNow2 = tNow;
          // Slam the visible scan plane yaw a bit
          scanner2.rotation.y += (Math.random() - 0.5) * 0.14 * (thunderEnergy + gateSharp*0.2);
          scanHitUniforms.uYaw.value = scanner2.rotation.y;
          // Wrap-pass yaw jitter + oscillation
          scanWrapUniforms.yaw.value += (Math.sin(tNow2 * 18.0) * 0.06 + (Math.random()-0.5) * 0.05) * (thunderEnergy + gateSharp*0.2);
          // Background subtle shake
          const shake = 0.070 * (thunderEnergy + gateSharp*0.85) * (state.sensPunchy ? 1.25 : 1.0) * (0.9 + 0.9*state.sensThunderIntensity);
          gridGroup.position.x = Math.sin(tNow2 * 30.0) * shake;
          gridGroup.position.z = Math.cos(tNow2 * 24.0) * shake;
          latticeGroup.position.x = Math.cos(tNow2 * 26.0) * shake * 0.6;
          latticeGroup.position.y = Math.sin(tNow2 * 22.0) * shake * 0.6;
          // Blocks: strong rotational jitter + per-frame scale jitter to sell impact, independent of Treble slider
          const jitter = (thunderEnergy + gateSharp*0.75) * (0.9 + 0.7*state.sensThunderIntensity);
          mesh.rotation.x += (Math.random()-0.5) * 0.16 * jitter;
          mesh.rotation.y += (Math.random()-0.5) * 0.14 * jitter;
          // Add a fast micro scale jitter on top of bass breath
          const micro = 1.0 + (Math.random()-0.5) * 0.35 * jitter;
          mesh.scale.setScalar(THREE.MathUtils.clamp(blockBreath * micro, 0.55, 2.8));
          // Spike scan thickness briefly on strobe
          if (scan2Uniforms && strobeEnergy > 0.01) {
            scan2Uniforms.uThickness.value += strobeEnergy * 0.6;
            scan2Uniforms.uSubThickness.value += strobeEnergy * 0.35;
          }
        }
        // Note: do NOT alter camera transform so user free-turn remains intact
        // Film noise punch
        if (film && film.uniforms && film.uniforms['nIntensity']) {
          film.uniforms['nIntensity'].value = 0.2 + Math.min(0.9, (tRaw + thunderEnergy + strobeEnergy) * 0.9);
        }
        prevTreble = gT; prevTrebleRaw = tRaw;
      } else {
        // reset when disabled
        thunderEnergy = 0.0; strobeEnergy = 0.0; prevTreble = 0.0; prevTrebleRaw = 0.0;
        // reset film intensity only (camera is untouched to preserve free turning)
        if (film && film.uniforms && film.uniforms['nIntensity']) {
          film.uniforms['nIntensity'].value = 0.25; // default
        }
      }
    }

    // -----------------------
    // Animate hook extensions
    // -----------------------
    animate();
    // Extend animate with UI + audio updates
    const __origAnimate = animate;
    function animateWrapper() {}
    // We cannot override the already running loop, so hook via rAF tasks
    let __uiLast = performance.now();
    ;(function uiLoop(){
      let now, dt;
      try {
        now = performance.now();
        dt = Math.max(0, (now - __uiLast) / 1000) * (window.__DEV_SPEED?.speedMul || 1);
        __uiLast = now;
        // Update analyser bands
        try { if (analyser) updateBands(); } catch (e) { console.error('updateBands error', e); }
        // Audio-reactive scene updates (guarded)
        try { applyAudioToScene(); } catch (e) { console.error('applyAudioToScene error', e); }
        // Drive scan phase speed. With Thunder on, vary strongly with bass; otherwise mild.
        const sB = (state.sensBass ?? 1);
        const gBapprox = audioStrength.bass * (sB * sB);
        const speedFactor = state.sensThunder ? (0.3 + gBapprox * 3.0) : (1.0 + gBapprox * 0.8);
        try { if (scan2Uniforms) scan2Uniforms.uTime.value += dt * speedFactor; } catch {}
        try { if (scanWrapUniforms) scanWrapUniforms.time.value += dt * speedFactor; } catch {}
        try { updateOverlay(); } catch (e) { console.error('updateOverlay error', e); }
        try { updatePlants(dt); } catch (e) { console.error('updatePlants error', e); }
      } catch (err) {
        console.error('uiLoop fatal error', err);
      } finally {
        requestAnimationFrame(uiLoop);
      }
    })();

    // =======================
    // Plants overlay visualizer
    // =======================
    let plantsRenderer = null;
    let plantsScene = null;
    let plantsOrtho = null;
    let plantsRoot = null;
    let plantsLastSpawn = 0;
    let plantsTargets = [];
    const PLANTS_SPAWN_INTERVAL = 6.0; // even slower spawning cadence
    const PLANTS_TARGET = 4;           // very few concurrent stems
    const MAX_PLANTS = 8;              // hard cap as a safety

    function ensurePlantsOverlay(){
      if (plantsRenderer) return;
      plantsScene = new THREE.Scene();
      const w = window.innerWidth, h = window.innerHeight;
      plantsOrtho = new THREE.OrthographicCamera(0, w, 0, h, -1000, 1000);
      plantsOrtho.position.z = 10;
      plantsRoot = new THREE.Group(); plantsScene.add(plantsRoot);
      plantsRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      plantsRenderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      plantsRenderer.setSize(w, h);
      plantsRenderer.setClearColor(0x000000, 0.0);
      const el = plantsRenderer.domElement; el.style.position='fixed'; el.style.inset='0'; el.style.zIndex='9002'; el.style.pointerEvents='none';
      document.body.appendChild(el);
    }

    // Prebuild a lathe leaf geometry for reuse
    function buildLeafGeometry(){
      const pts = [];
      const L = 14; // half-length profile
      for (let i=0;i<=12;i++){
        const t = i/16;
        const y = t * 24; // length
        const w = Math.sin(Math.PI * t) * 6.5 * (0.85 + 0.15*Math.cos(t*3.0));
        pts.push(new THREE.Vector2(Math.max(0.2, w), y));
      }
      const geo = new THREE.LatheGeometry(pts, 10);
      geo.computeVertexNormals();
      return geo;
    }
    const LEAF_GEOMETRY = buildLeafGeometry();
    class Leaf {
      constructor(x, y, dir){
        // Brighter green variation using HSL
        const c = new THREE.Color().setHSL(0.32 + (Math.random()*0.04-0.02), 0.7 + Math.random()*0.2, 0.48 + Math.random()*0.18);
        const mat = new THREE.MeshStandardMaterial({ color: c, emissive: c.clone().multiplyScalar(0.18), metalness: 0.06, roughness: 0.72, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        this.mesh = new THREE.Mesh(LEAF_GEOMETRY, mat);
        this.mesh.position.set(x, y, 0);
        this.mesh.rotation.z = dir + (Math.random()*0.6-0.3);
        this.scale = 0.25 + Math.random()*0.35;
        this.t = 0; // life
        this.swing = Math.random()*Math.PI*2;
        plantsRoot.add(this.mesh);
      }
      update(dt){
        this.t += dt;
        const treble = (typeof audioStrength !== 'undefined' && audioStrength && audioStrength.treble) ? audioStrength.treble : 0.0;
        const twk = 5.0 + treble * 18.0;
        this.swing += dt * (0.6 + treble*2.2);
        const twinkle = 0.85 + 0.25*Math.sin(this.t*twk + this.swing);
        const s = Math.min(1.25, this.scale + this.t*0.22) * twinkle;
        this.mesh.scale.set(s, s, 1);
        this.mesh.material.opacity = Math.min(0.7, this.t*1.0); // slightly transparent
        // gentle bend/turn
        this.mesh.rotation.z += 0.12*dt*Math.sin(this.swing*0.8);
        // fade when near top (y small in our ortho since top=0)
        if (this.mesh.position.y < 40) {
          this.mesh.material.opacity *= 0.985;
        }
        if (this.mesh.material.opacity < 0.02){ plantsRoot.remove(this.mesh); this.mesh.geometry.dispose?.(); this.mesh.material.dispose?.(); return false; }
        return true;
      }
    }

    class Stem {
      constructor(target, x, y, dir, depth=0){
        this.target = target; // {left,right,bottom}
        this.depth = depth;
        this.points = [ new THREE.Vector3(x, y, 0) ];
        this.len = 0;
        this.dir = dir;
        this.group = new THREE.Group(); plantsRoot.add(this.group);
        this.children = [];
        this.leaves = [];
        this.alive = true;
        this.opacity = 0.78; // slight transparency on stems
        this.windPhase = Math.random()*Math.PI*2;
        this.segmentMeshes = []; // small cylinders along curve
        this.nextBranchAt = 60 + Math.random()*60;
        this.age = 0; // seconds
        this.maxAge = 9.5 + Math.random()*6.0; // longer life then fade
        // Choose a brighter green variant per stem and reuse a single material for all segments
        const baseCol = new THREE.Color().setHSL(0.32 + (Math.random()*0.05-0.025), 0.65 + Math.random()*0.2, 0.42 + Math.random()*0.16);
        this.mat = new THREE.MeshStandardMaterial({ color: baseCol, emissive: baseCol.clone().multiplyScalar(0.15), roughness: 0.84, metalness: 0.06, transparent: true, opacity: this.opacity });
      }
      head(){ return this.points[this.points.length-1]; }
      update(dt){
        if (!this.alive) return false;
        this.age += dt;
        const bass = (typeof audioStrength!=='undefined' && audioStrength && audioStrength.bass)||0.0;
        const mid  = (typeof audioStrength!=='undefined' && audioStrength && audioStrength.mid)||0.0;
        // Growth controlled by mid
        const growSpeed = 36 + mid*90 + Math.random()*8; // much slower base growth
        const step = growSpeed * dt;
        // determine new control point with gentle curvature + wind sway
        this.windPhase += dt * (0.6 + mid*0.8);
        const sway = Math.sin(this.windPhase) * 0.35;
        const dirJitter = (Math.random()*0.3 - 0.15) + sway;
        const ndir = this.dir + dirJitter;
        const hx = this.head().x + Math.cos(ndir) * step;
        const hy = this.head().y - Math.sin(ndir) * step;
        // clamp within window horizontal bounds (leave 8px margin)
        const minX = this.target.left + 8;
        const maxX = this.target.right - 8;
        const cx = Math.max(minX, Math.min(maxX, hx));
        const ny = hy;
        this.points.push(new THREE.Vector3(cx, ny, 0));
        this.len += step;
        this.dir = ndir * 0.8 + this.dir * 0.2; // smooth dir
        // add leaf sometimes
        if (Math.random() < 0.12) {
          this.leaves.push(new Leaf(cx, ny, this.dir + (Math.random()<0.5?-1:1)*0.6));
        }
        // rebuild small cylinder segment for the last step to simulate a Tube with taper
        const segIdx = this.points.length-2; if (segIdx>=0){
          const a = this.points[segIdx]; const b = this.points[segIdx+1];
          const segLen = a.distanceTo(b);
          const bassInfl = 1.0 + bass * 1.2; // thickness with bass
          const baseR = Math.max(0.6, 1.9 * bassInfl * (1.0 - Math.min(1.0, this.len/600)) * (1.0 - this.depth*0.5));
          const rTop = Math.max(0.5, baseR * 0.7);
          const geo = new THREE.CylinderGeometry(rTop, baseR, segLen, 6, 1, true);
          const mesh = new THREE.Mesh(geo, this.mat);
          // orient from a to b
          const ang = Math.atan2(b.y - a.y, b.x - a.x);
          mesh.rotation.z = -ang + Math.PI/2;
          // position at midpoint
          mesh.position.set((a.x+b.x)/2, (a.y+b.y)/2, 0);
          this.group.add(mesh);
          this.segmentMeshes.push(mesh);
        }
        // branching influenced by bass
        // Branching disabled for minimal clutter and perf
        // update leaves
        this.leaves = this.leaves.filter(l => l.update(dt));
        // fade out when near top OR after living long enough OR too long length on screen
        const grownHeight = (this.target.bottom - this.head().y);
        const tooLong = grownHeight > (window.innerHeight * 0.25); // fade very early
        if (this.head().y <= 0 || this.age >= this.maxAge || tooLong) {
          this.opacity *= 0.94; // faster fade
          this.mat.opacity = this.opacity;
          if (this.opacity < 0.03) { this.dispose(); return false; }
        }
        // children
        this.children = this.children.filter(c => c.update(dt));
        return true;
      }
      dispose(){
        this.alive = false;
        this.segmentMeshes.forEach(m => { m.geometry.dispose?.(); m.material.dispose?.(); });
        try { plantsRoot.remove(this.group); } catch {}
      }
    }

    let stems = [];

    function collectPlantTargets(){
      plantsTargets = [];
      const wins = document.querySelectorAll('.video-window');
      wins.forEach(w => {
        if (w.style.display === 'none') return;
        const r = w.getBoundingClientRect();
        // weight by width (density per window)
        const weight = Math.max(1, Math.floor((r.right - r.left) / 200));
        for (let i=0;i<weight;i++) plantsTargets.push({ left: r.left, right: r.right, bottom: r.bottom });
      });
    }

    function spawnStem(){
      if (!plantsTargets.length) return;
      const t = plantsTargets[Math.floor(Math.random()*plantsTargets.length)];
      const x = t.left + Math.random() * Math.max(1, (t.right - t.left));
      const y = t.bottom; // start at window bottom edge
      const dir = Math.PI/2 + (Math.random()*0.3 - 0.15); // generally upward
      stems.push(new Stem(t, x, y, dir, 0));
      if (stems.length > MAX_PLANTS) stems.shift();
    }

    function setPlantsEnabled(on){
      if (on) {
        ensurePlantsOverlay();
        plantsRenderer.domElement.style.display = '';
        // Refresh targets and prime immediate spawn so user sees plants quickly
        collectPlantTargets();
        // If we have targets, spawn at least one immediately and reset timer
        if (plantsTargets.length > 0 && stems.length === 0) {
          spawnStem();
        }
        plantsLastSpawn = PLANTS_SPAWN_INTERVAL; // trigger next scheduled spawn ASAP
      } else {
        if (plantsRenderer) plantsRenderer.domElement.style.display = 'none';
        // Clear all stems immediately
        stems.forEach(s => s.dispose());
        stems = [];
        // Also clear any leftover nodes from the plants scene
        if (plantsRoot) {
          while (plantsRoot.children.length) {
            const n = plantsRoot.children.pop();
            try { n.traverse?.(obj => { obj.geometry?.dispose?.(); obj.material?.dispose?.(); }); } catch {}
          }
        }
        // Reset targets and timers
        plantsTargets = [];
        plantsLastSpawn = 0;
      }
    }

    function updatePlants(dt){
      if (!state.plantsEnabled) return;
      if (!plantsRenderer) ensurePlantsOverlay();
      // refresh targets occasionally (windows move/resize)
      plantsLastSpawn += dt;
      if (plantsLastSpawn > 0.45) { collectPlantTargets(); }
      // only spawn when under target density and interval has elapsed
      if ((stems.length === 0 && plantsTargets.length > 0) || (plantsLastSpawn >= PLANTS_SPAWN_INTERVAL && stems.length < PLANTS_TARGET)) {
        spawnStem(); plantsLastSpawn = 0;
      }
      // update stems
      stems = stems.filter(s => s.update(dt));
      // render on transparent canvas above all windows
      plantsRenderer.autoClear = true;
      plantsRenderer.render(plantsScene, plantsOrtho);
    }

    // Activate initial state
    setPlantsEnabled(!!state.plantsEnabled);
  </script>
  <!-- Dev Settings Modal (body-level, top-right anchored) -->
  <div id="devModal" role="dialog" aria-label="Developer Settings">
    <div class="head">
      <strong>Developer Settings</strong>
      <button id="btnDevClose" class="btn-sm" title="Close">✖</button>
    </div>
    <div class="body">
        <div class="section">
          <div class="pill" style="margin-bottom:6px;">Toggle Parts</div>
        <label><input type="checkbox" id="devShowScanner" checked /> Scan Line /Plane</label>
        <label><input type="checkbox" id="devShowBlockGrid" checked /> Rotating Blocks / Block Grid</label>
        <label><input type="checkbox" id="devShowMonoliths" checked /> Surrounding Monolith Blocks</label>
        <label><input type="checkbox" id="devShowShards" checked /> Shards Swarm</label>
        <label><input type="checkbox" id="devShowBlockScans" checked /> Block Scans / Wrap Scan</label>
        <label><input type="checkbox" id="devShowLattice" checked /> Lattice / Thin Grids</label>
        <label><input type="checkbox" id="devShowWires" checked /> Wires / Streamers</label>
        <label><input type="checkbox" id="devShowPulses" checked /> Pulse Spheres</label>
        <label><input type="checkbox" id="devShowFireflies" checked /> Fireflies</label>
          <label><input type="checkbox" id="devShowEmbers" checked /> Embers</label>
          <label><input type="checkbox" id="devShowLightning" checked /> Thunder Lightning</label>
          <label><input type="checkbox" id="devShowBackdrop" checked /> Backdrop / Background</label>
      </div>
        <div class="pill" style="margin-bottom:6px;">Extra Effects</div>
        <label>Cube Face Image URL
          <input type="url" id="devCubeMapUrl" placeholder="https://example.com/texture.jpg" />
        </label>
        <label>Full-screen Overlay Image URL
          <input type="url" id="devOverlayUrl" placeholder="https://example.com/overlay.png" />
        </label>
        <label>Overlay Opacity
          <input type="range" id="devOverlayOpacity" min="0" max="1" step="0.01" value="0.5" />
        </label>
        <label>Global Speed Multiplier
          <input type="number" id="devSpeedMul" min="0" step="0.1" value="1" />
        </label>
        <label>Global Color Tint
          <input type="color" id="devTint" value="#e7c39a" />
        </label>
        <div class="section">
          <div class="pill" style="margin-bottom:6px;">Wrap Scan Tuning</div>
          <label title="Multiply Gaussian cross-falloff width (softer lines)">
            Gauss Width ×
            <input type="range" id="devGwMul" min="0.5" max="2" step="0.01" value="1" />
            <input type="checkbox" id="devGwBoost" /> Boost
          </label>
          <label title="Multiply sinusoidal wobble amplitude">
            Wobble ×
            <input type="range" id="devWobbleMul" min="0" max="2" step="0.01" value="1" />
            <input type="checkbox" id="devWobbleBoost" /> Boost
          </label>
          <label title="Multiply noise-based shimmer intensity">
            Noise ×
            <input type="range" id="devNoiseMul" min="0" max="2" step="0.01" value="1" />
            <input type="checkbox" id="devNoiseBoost" /> Boost
          </label>
        </div>
        <div style="display:flex; gap:6px; justify-content:flex-end;">
          <button id="devApply" class="btn-sm">Apply</button>
          <button id="devReset" class="btn-sm">Reset</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Overlay image element for Dev Settings full-screen overlay effect -->
  <img id="devOverlayImg" alt="overlay" style="display:none; position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:8000; object-fit:contain; object-position:center center; opacity:0.5;" />
  <!-- YouTube IFrame API (audio-only use; player hidden via CSS we can add later if we integrate) -->
  <script src="https://www.youtube.com/iframe_api" defer></script>
</body>
</html>
